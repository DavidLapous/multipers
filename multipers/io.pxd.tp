{{py:
"""
Vine and non-vine slicers.
both type have the same interface, defined the slicer.pyx file
"""

## generation with another file as Tempita is slightly bugged for python <3.12
import pickle
with open("build/tmp/_slicer_names.pkl", "rb") as f:
    slicers = pickle.load(f)

}}

from libcpp.string cimport string
from libcpp cimport bool, int

from cython.operator cimport dereference
import multipers.slicer as mps
from multipers.slicer cimport *


cdef extern from "gudhi/scc_io.h":
    {{for CTYPE_H, CTYPE,PYTHON_TYPE, IS_SIMPLICIAL, IS_VINE, IS_KCRITICAL, C_VALUE_TYPE, PY_VALUE_TYPE, COL, SHORT, FILTRATION_TYPE  in slicers}}
    {{if not IS_KCRITICAL}}
    void write_scc_file(string, {{CTYPE}}&, int, int, bool, bool, bool, bool) except + nogil
    {{endif}}
    {{endfor}}


cdef inline void _write_scc_file_from_slicer(string path, object slicer, int num_parameters, int degree, bool rivet_compatible, bool ignore_last_generators, bool strip_comments, bool reverse):
    cdef intptr_t slicer_ptr = <intptr_t>(slicer.get_ptr())

    if False:   #just to enable the following loop
        pass
    {{for CTYPE_H, CTYPE,PYTHON_TYPE, IS_SIMPLICIAL, IS_VINE, IS_KCRITICAL, C_VALUE_TYPE, PY_VALUE_TYPE, COL, SHORT, FILTRATION_TYPE  in slicers}}
    {{if not IS_KCRITICAL}}
    elif isinstance(slicer, mps.{{PYTHON_TYPE}}):
        with nogil:
            write_scc_file(path, dereference(<{{CTYPE}}*>(slicer_ptr)), num_parameters, degree, rivet_compatible, ignore_last_generators, strip_comments, reverse)
    {{endif}}
    {{endfor}}
    else:
        raise ValueError(f"Unsupported slicer type {type(slicer)}")

cdef extern from "gudhi/scc_io.h":
    {{for CTYPE_H, CTYPE,PYTHON_TYPE, IS_SIMPLICIAL, IS_VINE, IS_KCRITICAL, C_VALUE_TYPE, PY_VALUE_TYPE, COL, SHORT, FILTRATION_TYPE  in slicers}}
    {{if not IS_KCRITICAL}}
    {{CTYPE}} read_scc_file[{{CTYPE}}](string, bool) except + nogil
    {{endif}}
    {{endfor}}

{{for CTYPE_H, CTYPE,PYTHON_TYPE, IS_SIMPLICIAL, IS_VINE, IS_KCRITICAL, C_VALUE_TYPE, PY_VALUE_TYPE, COL, SHORT, FILTRATION_TYPE  in slicers}}
{{if not IS_KCRITICAL}}
cdef inline void _read_scc_file_{{PYTHON_TYPE}}(object slicer, string path, bool rivet_compatible):
    cdef {{CTYPE}} cslicer = read_scc_file[{{CTYPE}}](path, rivet_compatible)
    slicer._from_ptr(<intptr_t>(&cslicer))
{{endif}}
{{endfor}}

cdef inline void _read_scc_file_as_slicer(object slicer, string path, bool rivet_compatible):
    if False:   #just to enable the following loop
        pass
    {{for CTYPE_H, CTYPE,PYTHON_TYPE, IS_SIMPLICIAL, IS_VINE, IS_KCRITICAL, C_VALUE_TYPE, PY_VALUE_TYPE, COL, SHORT, FILTRATION_TYPE  in slicers}}
    {{if not IS_KCRITICAL}}
    elif isinstance(slicer, mps.{{PYTHON_TYPE}}):
        _read_scc_file_{{PYTHON_TYPE}}(slicer, path, rivet_compatible)
    {{endif}}
    {{endfor}}
    else:
        raise ValueError(f"Unsupported slicer type {type(slicer)}")
