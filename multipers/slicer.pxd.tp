{{py:
"""
Vine and non-vine slicers.
both type have the same interface, defined the slicer.pyx file
"""

## generation with another file as Tempita is slightly bugged for python <3.12
import pickle
with open("build/tmp/_slicer_names.pkl", "rb") as f:
  slicers = pickle.load(f)

# TODO: FIXME. This is not possible as the import is hardcoded as f32 and f64.
# float_value_types = set([(D['C_VALUE_TYPE'],D['PY_VALUE_TYPE'],D['SHORT_VALUE_TYPE']) for D in slicers if D['IS_FLOAT']])

float_value_types = set((("float",   "np.float32", "f32"), ("double",  "np.float64", "f64")) )

with open("build/tmp/_simplextrees_.pkl", "rb") as f:
    simplex_trees = pickle.load(f)

}}

cimport numpy as cnp

# SequentialDataset and its two concrete subclasses are (optionally randomized)
# iterators over the rows of a matrix X and corresponding target values y.

from libcpp.utility cimport pair 
from libcpp cimport bool, int, float
from libcpp.vector cimport vector


from libc.stdint cimport intptr_t, uint16_t, uint32_t, int32_t, uint64_t, int64_t
from cython cimport uint

import numpy as np
python_value_type=np.float32
from libcpp.string cimport string

cdef extern from "Simplex_tree_multi_interface.h" namespace "Gudhi::multiparameter::python_interface":
    cdef cppclass Simplex_tree_multi_interface[F=*, value_type=*]:
        pass

from multipers.filtrations cimport *
ctypedef  vector[uint] cycle_type ## its the cycle type of matrix

cdef extern from "gudhi/Multi_parameter_filtered_complex.h" namespace "Gudhi::multi_persistence":
    cdef cppclass Multi_parameter_filtered_complex[F]:
        Multi_parameter_filtered_complex()
        Multi_parameter_filtered_complex(vector[vector[uint32_t]]&, vector[int]&, vector[F]&)

{{for D in slicers}}
#------------------------------------------------------------------------------
cdef extern from "Persistence_slices_interface.h" namespace "multipers::tmp_interface":
  cdef cppclass Bar[T]:
      pass
  
  cdef cppclass Barcode[S, T]:
      size_t size()
      Bar[T]* data()

  cdef cppclass Dim_barcode[S, T]:
      size_t size()
      Barcode[S,T]& operator[](size_t)

  cdef cppclass {{D['C_TEMPLATE_TYPE']}} "{{D['TRUC_TYPE']}}":
      ctypedef {{D['C_VALUE_TYPE']}} value_type

      {{D['C_TEMPLATE_TYPE']}}()
      {{D['C_TEMPLATE_TYPE']}}(Multi_parameter_filtered_complex[{{D['FILTRATION_TYPE']}}]&)
      {{D['C_TEMPLATE_TYPE']}}& operator=(const {{D['C_TEMPLATE_TYPE']}}&)

      uint32_t num_generators "get_number_of_cycle_generators"() nogil
      uint32_t num_parameters "get_number_of_parameters"() nogil
      {{if D['IS_VINE']}}
      vector[uint32_t] get_current_order() nogil
      void vineyard_update() nogil
      vector[vector[vector[uint32_t]]] get_representative_cycles(bool) nogil
      vector[uint32_t] get_most_persistent_cycle(int, bool) nogil
      {{endif}}
      vector[{{D['C_VALUE_TYPE']}}] get_one_filtration "get_slice"()
      pair[{{D['FILTRATION_TYPE']}}, {{D['FILTRATION_TYPE']}}] get_bounding_box() except + nogil
      vector[{{D['FILTRATION_TYPE']}}]& get_filtrations "get_filtration_values"() nogil
      vector[int] get_dimensions() nogil
      int get_dimension(uint32_t) nogil
      const vector[vector[uint32_t]]& get_boundaries() nogil
      vector[uint32_t] get_boundary(uint32_t) nogil
      void set_one_filtration "set_slice"(const vector[{{D['C_VALUE_TYPE']}}]&) nogil
      void push_to(const Line[{{D['C_VALUE_TYPE']}}]&) nogil
      int prune_above_dimension(int) except + nogil 
      void coarsen_on_grid_inplace "coarsen_on_grid"(vector[vector[{{D['C_VALUE_TYPE']}}]], bool) nogil
      void initialize_persistence_computation(bool) except+ nogil
      void initialize_persistence_computation() except+ nogil # ignore_inf = true
      Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, {{D['C_VALUE_TYPE']}}] get_barcode "get_flat_barcode<true, {{D['C_VALUE_TYPE']}}, false>"() nogil
      Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, int] get_barcode_idx "get_flat_barcode<true, int, true>"() nogil
  string slicer_to_str({{D['C_TEMPLATE_TYPE']}}&) nogil #to_str
  {{D['C_TEMPLATE_TYPE']}} build_permuted_slicer "build_permuted_slicer"({{D['C_TEMPLATE_TYPE']}}&, vector[uint32_t]&) except + nogil #permute
  pair[{{D['C_TEMPLATE_TYPE']}}, vector[uint32_t]] build_permuted_slicer "build_permuted_slicer"({{D['C_TEMPLATE_TYPE']}}&) except + nogil #colexical_rearange
  {{if D['COLUMN_TYPE'] is not None}}
  {{D['C_TEMPLATE_TYPE'][:-3]+"i32"}} build_slicer_coarsen_on_grid "build_slicer_coarsen_on_grid"({{D['C_TEMPLATE_TYPE']}}&, vector[vector[{{D['C_VALUE_TYPE']}}]]&) nogil #coarsen_on_grid
  {{endif}}
  {{if D['COLUMN_TYPE'] is not None}}
  {{D['C_TEMPLATE_TYPE']}} build_slicer_from_projective_cover_kernel "build_slicer_from_projective_cover_kernel"({{D['C_TEMPLATE_TYPE']}}&, int) except + nogil #projective_cover_kernel
  {{endif}}
  void write_slicer_to_scc_file "write_slicer_to_scc_file"(string&, {{D['C_TEMPLATE_TYPE']}}&, int, bool, bool, bool, bool) nogil #write_to_scc_file

#------------------------------------------------------------------------------
cdef extern from "gudhi/slicer_helpers.h" namespace "Gudhi::multi_persistence":
  {{if not D['IS_KCRITICAL']}}
  {{D['C_TEMPLATE_TYPE']}} build_slicer_from_scc_file_{{D['C_TEMPLATE_TYPE']}} "Gudhi::multi_persistence::build_slicer_from_scc_file<{{D['TRUC_TYPE']}}>"(string&, bool, bool, int) except + nogil #build_from_scc_file
  {{endif}}
  {{for ST in simplex_trees}}
  {{D['C_TEMPLATE_TYPE']}} build_slicer_from_simplex_tree_{{D['C_TEMPLATE_TYPE']}}_{{ST["PyFil"]}} "Gudhi::multi_persistence::build_slicer_from_simplex_tree<{{D['TRUC_TYPE']}}>"({{ST["ST_INTERFACE"]}}&) except + nogil
  {{endfor}}
  {{D['C_TEMPLATE_TYPE']}} build_slicer_from_bitmap_{{D['C_TEMPLATE_TYPE']}} "Gudhi::multi_persistence::build_slicer_from_bitmap<{{D['TRUC_TYPE']}}>"(vector[{{D['FILTRATION_TYPE']}}], vector[unsigned int]) except + nogil
  vector[Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, int]] custom_persistences "persistence_on_slices<{{D['TRUC_TYPE']}}, {{D['C_VALUE_TYPE']}}, int, true>"({{D['C_TEMPLATE_TYPE']}}&, {{D['C_VALUE_TYPE']}}*, int, bool) except + nogil
  vector[Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, {{D['C_VALUE_TYPE']}}]] persistence_on_lines "persistence_on_slices"({{D['C_TEMPLATE_TYPE']}}&, vector[vector[{{D['C_VALUE_TYPE']}}]]&, vector[vector[{{D['C_VALUE_TYPE']}}]]&, bool) except + nogil

cdef inline _b2np_{{D['C_TEMPLATE_TYPE']}}(const Barcode[{{D['C_TEMPLATE_TYPE']}}, {{D['C_VALUE_TYPE']}}]& barcode):
  cdef Py_ssize_t size = barcode.size() * 2
  if size == 0:
    return np.empty(shape=(0, 2), dtype={{D['PY_VALUE_TYPE']}})
  cdef {{D['C_VALUE_TYPE']}}[:] view = <{{D['C_VALUE_TYPE']}}[:size]>(<{{D['C_VALUE_TYPE']}}*>(barcode.data()))
  #copy as the barcode will very probably be destroyed afterwards
  return np.array(view).reshape((-1, 2))

cdef inline _db2np_{{D['C_TEMPLATE_TYPE']}}(const Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, {{D['C_VALUE_TYPE']}}]& barcode):
  cdef Py_ssize_t dims = barcode.size()
  return [_b2np_{{D['C_TEMPLATE_TYPE']}}(barcode[i]) for i in range(dims)]

cdef inline _b2np_{{D['C_TEMPLATE_TYPE']}}_idx(const Barcode[{{D['C_TEMPLATE_TYPE']}}, int]& barcode):
  cdef Py_ssize_t size = barcode.size() * 2
  if size == 0:
    return np.empty(shape=(0, 2), dtype=np.dtype(int))
  cdef int[:] view = <int[:size]>(<int*>(barcode.data()))
  #copy as the barcode will very probably be destroyed afterwards
  return np.array(view).reshape((-1, 2))

cdef inline _db2np_{{D['C_TEMPLATE_TYPE']}}_idx(const Dim_barcode[{{D['C_TEMPLATE_TYPE']}}, int]& barcode):
  cdef Py_ssize_t dims = barcode.size()
  return [_b2np_{{D['C_TEMPLATE_TYPE']}}_idx(barcode[i]) for i in range(dims)]

{{endfor}}


#### MMA Stuff

from multipers.mma_structures cimport Module
cdef extern from "multiparameter_module_approximation/approximation.h" namespace "Gudhi::multiparameter::mma":
{{for D in slicers}}
  {{if D['IS_VINE'] and D['IS_FLOAT']}}
  Module[{{D['C_VALUE_TYPE']}}] multiparameter_module_approximation({{D['C_TEMPLATE_TYPE']}}&, vector[{{D['C_VALUE_TYPE']}}]&, {{D['C_VALUE_TYPE']}}, Box[{{D['C_VALUE_TYPE']}}]&, bool, bool, bool) except + nogil
  {{endif}}
  {{endfor}}
  pass




import multipers.slicer as mps
from cython.operator cimport dereference
{{for C_VALUE_TYPE,PYTHON_VALUE_TYPE,SHORT_VALUE_TYPE in float_value_types}}
cdef inline Module[{{C_VALUE_TYPE}}] _multiparameter_module_approximation_{{SHORT_VALUE_TYPE}}(object slicer, vector[{{C_VALUE_TYPE}}] direction, {{C_VALUE_TYPE}} max_error, Box[{{C_VALUE_TYPE}}] box, bool threshold, bool complete, bool verbose):
  import multipers.slicer as mps
  cdef intptr_t slicer_ptr = <intptr_t>(slicer.get_ptr())
  cdef Module[{{C_VALUE_TYPE}}] mod
  if False:
    pass
  {{for D in slicers}}
  {{if D['IS_VINE'] and D['SHORT_VALUE_TYPE'] == SHORT_VALUE_TYPE}} 
  elif isinstance(slicer, mps.{{D['PYTHON_TYPE']}}):
    with nogil:
      mod = multiparameter_module_approximation(dereference(<{{D['C_TEMPLATE_TYPE']}}*>(slicer_ptr)), direction, max_error, box, threshold, complete, verbose)
    return mod
  {{endif}}
  {{endfor}}
  else:
    raise ValueError(f"Unsupported slicer type {type(slicer)}")
{{endfor}}

###### RANK INVARIANT
from libc.stdint cimport intptr_t, uint16_t, uint32_t, int32_t, int16_t, int8_t
ctypedef int32_t tensor_dtype
ctypedef int32_t indices_type
python_indices_type=np.int32
python_tensor_dtype = np.int32



ctypedef pair[vector[vector[indices_type]], vector[tensor_dtype]] signed_measure_type



cdef extern from "multi_parameter_rank_invariant/rank_invariant.h" namespace "Gudhi::multiparameter::rank_invariant":
  ## from slicers
{{for D in slicers}}
    void compute_rank_invariant_python({{D['C_TEMPLATE_TYPE']}}&, tensor_dtype* , const vector[indices_type], const vector[indices_type], indices_type, bool ignore_inf) except + nogil
    signed_measure_type compute_rank_signed_measure({{D['C_TEMPLATE_TYPE']}}&, tensor_dtype* , const vector[indices_type], const vector[indices_type], indices_type, bool verbose, bool ignore_inf) except + nogil
  {{endfor}}





cdef inline void _compute_rank_invariant(object slicer, tensor_dtype* container_ptr, vector[indices_type] c_grid_shape, vector[indices_type] degrees, int n_jobs, bool ignore_inf):
  import multipers.slicer as mps
  cdef intptr_t slicer_ptr = <intptr_t>(slicer.get_ptr())
{{for D in slicers}}
  if isinstance(slicer, mps.{{D['PYTHON_TYPE']}}):
    with nogil:
      compute_rank_invariant_python(dereference(<{{D['C_TEMPLATE_TYPE']}}*>(slicer_ptr)),container_ptr, c_grid_shape,degrees, n_jobs,ignore_inf)
      return
  {{endfor}}
  raise ValueError(f"Unsupported slicer type {type(slicer)}")



cdef inline  _compute_rank_sm(object slicer, tensor_dtype* container_ptr, vector[indices_type] c_grid_shape, vector[indices_type] degrees, int n_jobs, bool verbose, bool ignore_inf):
  import multipers.slicer as mps
  cdef intptr_t slicer_ptr = <intptr_t>(slicer.get_ptr())
  cdef signed_measure_type sm
  cdef cnp.ndarray[indices_type, ndim=2] pts
  cdef cnp.ndarray[tensor_dtype, ndim=1] weights
{{for D in slicers}}
  if isinstance(slicer, mps.{{D['PYTHON_TYPE']}}):
    with nogil:
      sm = compute_rank_signed_measure(dereference(<{{D['C_TEMPLATE_TYPE']}}*>(slicer_ptr)),container_ptr, c_grid_shape,degrees, n_jobs, verbose, ignore_inf)
    pts = np.asarray(sm.first,dtype=python_indices_type)
    weights = np.asarray(sm.second,dtype=python_tensor_dtype)
    return (pts,weights)
  {{endfor}}
  raise ValueError(f"Unsupported slicer type {type(slicer)}")



#### Hilbert Function

cdef extern from "multi_parameter_rank_invariant/hilbert_function.h" namespace "Gudhi::multiparameter::hilbert_function":
  ## from slicers
{{for D in slicers}}
    signed_measure_type get_hilbert_signed_measure({{D['C_TEMPLATE_TYPE']}}&, tensor_dtype* , const vector[indices_type], const vector[indices_type],  bool zero_pad,indices_type n_jobs, bool verbose, bool ignore_inf) except + nogil
  {{endfor}}
cdef inline  _compute_hilbert_sm(slicer, tensor_dtype* container_ptr, vector[indices_type] c_grid_shape, vector[indices_type] degrees, int n_jobs, bool verbose,bool zero_pad, bool ignore_inf):
  import multipers.slicer as mps
  if len(slicer) == 0:
    return (np.empty(shape=(0, 1), dtype=slicer.dtype), np.empty(shape=(0), dtype=int))
  cdef intptr_t slicer_ptr = <intptr_t>(slicer.get_ptr())
  cdef signed_measure_type sm
  cdef cnp.ndarray[indices_type, ndim=2] pts
  cdef cnp.ndarray[tensor_dtype, ndim=1] weights
{{for D in slicers}}
  if isinstance(slicer, mps.{{D['PYTHON_TYPE']}}):
    with nogil:
      sm = get_hilbert_signed_measure(dereference(<{{D['C_TEMPLATE_TYPE']}}*>(slicer_ptr)),container_ptr, c_grid_shape,degrees, zero_pad, n_jobs, verbose, ignore_inf)
    if len(sm.first) == 0:
      pts = np.empty(shape=(0, slicer.num_parameters), dtype=python_indices_type)
      weights = np.empty(shape=(0), dtype=python_tensor_dtype)
    else:
      pts = np.asarray(sm.first,dtype=python_indices_type)
      weights = np.asarray(sm.second,dtype=python_tensor_dtype)
    return (pts,weights)
  {{endfor}}
  raise ValueError(f"Unsupported slicer type {type(slicer)}")
