{{py:

"""
Templated simplextree multi
"""

import pickle 
with open("build/tmp/_simplextrees_.pkl", "rb") as f:
    to_iter = pickle.load(f)

st_map = {}
for CTYPE,PYTYPE, SHORT,Filtration, is_kcritical, FSHORT in to_iter:
    st_map[PYTYPE, is_kcritical] = CTYPE

}}




# This file is part of the Gudhi Library - https://gudhi.inria.fr/ - which is released under MIT.
# See file LICENSE or go to https://gudhi.inria.fr/licensing/ for full license details.
# Author(s):       Vincent Rouvreau
#
# Copyright (C) 2016 Inria
#
# Modification(s):
#  - 2023 David Loiseaux : Conversions with standard simplextree, scc2020 format, edge collapses, euler characteristic, grid filtrations.
#  - 2022/11 Hannah Schreiber / David Loiseaux : adapt for multipersistence. 
#   - YYYY/MM Author: Description of the modification



__author__ = "Vincent Rouvreau"
__copyright__ = "Copyright (C) 2016 Inria"
__license__ = "MIT"

from libc.stdint cimport intptr_t, int32_t, int64_t
from cython.operator import dereference, preincrement
from libc.stdint cimport intptr_t
from libc.stdint cimport uintptr_t, intptr_t
from libcpp.map cimport map
from libcpp.utility cimport pair

ctypedef fused some_int:
    int32_t
    int64_t
    int

ctypedef fused some_float:
    float
    double
    int32_t
    int64_t

ctypedef vector[pair[pair[int,int],pair[float,float]]] edge_list_type

from typing import Any, Union, ClassVar

cimport numpy as cnp
import numpy as np
cnp.import_array()

from multipers.simplex_tree_multi cimport *
from multipers.filtration_conversions cimport *
cimport cython
from gudhi.simplex_tree import SimplexTree ## Small hack for typing
from typing import Iterable,Literal,Optional
from tqdm import tqdm
from multipers.grids import Lstrategies, compute_grid, sanitize_grid
from multipers.array_api import api_from_tensor
from multipers.point_measure import signed_betti, rank_decomposition_by_rectangles, sparsify

from warnings import warn

SAFE_CONVERSION=False #Slower but at least it works everywhere

_available_strategies =Lstrategies



{{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}



ctypedef {{Filtration}} {{FSHORT}} 



# SimplexTree python interface
cdef class SimplexTreeMulti_{{FSHORT}}:
    """The simplex tree is an efficient and flexible data structure for
    representing general (filtered) simplicial complexes. The data structure
    is described in Jean-Daniel Boissonnat and Clément Maria. The Simplex
    Tree: An Efficient Data Structure for General Simplicial Complexes.
    Algorithmica, pages 1–22, 2014.

    This class is a multi-filtered, with keys, and non contiguous vertices version
    of the simplex tree. 
    """
    cdef public intptr_t thisptr

    cdef public object filtration_grid
    cdef public bool _is_function_simplextree  # TODO : deprecate
    # Get the pointer casted as it should be
    cdef Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]* get_ptr(self) noexcept nogil:
        return <Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]*>(self.thisptr)

    # cdef Simplex_tree_persistence_interface * pcohptr
    # Fake constructor that does nothing but documenting the constructor
    def __init__(self, other = None, num_parameters:int=-1,default_values=[], safe_conversion=False):
        """SimplexTreeMulti constructor.

        :param other: If `other` is `None` (default value), an empty `SimplexTreeMulti` is created.
            If `other` is a `SimplexTree`, the `SimplexTreeMulti` is constructed from a deep copy of `other`.
            If `other` is a `SimplexTreeMulti`, the `SimplexTreeMulti` is constructed from a deep copy of `other`.
        :type other: SimplexTree or SimplexTreeMulti (Optional)
        :param num_parameters: The number of parameter of the multi-parameter filtration.
        :type num_parameters: int
        :returns: An empty or a copy simplex tree.
        :rtype: SimplexTreeMulti

        :raises TypeError: In case `other` is neither `None`, nor a `SimplexTree`, nor a `SimplexTreeMulti`.
        """
    
    @staticmethod
    cdef {{CTYPE}} T_minus_inf():
          {{if SHORT[0] == 'f'}}
      return <{{CTYPE}}>(-np.inf)
          {{else}}
      return <{{CTYPE}}>(np.iinfo({{PYTYPE}}).min)
          {{endif}}
    @staticmethod
    cdef {{CTYPE}} T_inf():
          {{if SHORT[0] == 'f'}}
      return <{{CTYPE}}>(np.inf)
          {{else}}
      return <{{CTYPE}}>(np.iinfo({{PYTYPE}}).max)
          {{endif}}
    @property
    def is_kcritical(self)->bool:
      return {{is_kcritical}}
    # The real cython constructor
    def __cinit__(self, other = None, int num_parameters=-1, 
                  default_values=np.asarray([SimplexTreeMulti_{{FSHORT}}.T_minus_inf()]), # I'm not sure why `[]` does not work. Cython bug ? 
                  bool safe_conversion=False,
                  ): #TODO doc
        {{if is_kcritical}}
        cdef {{FSHORT}} c_default_values = _py2kc_{{SHORT}}(np.asarray([default_values], dtype= {{PYTYPE}}))
        {{else}}
        cdef {{FSHORT}} c_default_values = _py21c_{{SHORT}}(np.asarray(default_values, dtype={{PYTYPE}}))
        {{endif}}
        cdef intptr_t other_ptr
        cdef char[:] buffer
        cdef size_t buffer_size
        cdef char* buffer_start
        if other is not None:
            if isinstance(other, SimplexTreeMulti_{{FSHORT}}):
                other_ptr = other.thisptr
                self.thisptr = <intptr_t>(new Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}](dereference(<Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]*>other_ptr))) ## prevents calling destructor of other
                if num_parameters <=0:
                    num_parameters = other.num_parameters
                self.filtration_grid = other.filtration_grid
            elif isinstance(other, SimplexTree): # Constructs a SimplexTreeMulti from a SimplexTree
                self.thisptr = <intptr_t>(new Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]())
                if num_parameters <= 0:
                    num_parameters = 1
                if safe_conversion or SAFE_CONVERSION:
                    new_st_multi  = _safe_simplextree_multify_{{FSHORT}}(other, num_parameters = num_parameters, default_values=np.asarray(default_values))
                    self.thisptr, new_st_multi.thisptr = new_st_multi.thisptr, self.thisptr
                else:
                    stree_buffer = other.__getstate__()
                    buffer = stree_buffer
                    buffer_size = buffer.shape[0]
                    buffer_start = &buffer[0]

                    with nogil:
                        self.get_ptr().from_std(buffer_start, buffer_size, num_parameters, c_default_values)
            else:
                raise TypeError("`other` argument requires to be of type `SimplexTree`, `SimplexTreeMulti`, or `None`.")
        else:
            if num_parameters <=0:
                num_parameters = 2 # I don't know how dangerous this is, but this is mostly used.
            self.thisptr = <intptr_t>(new Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]())
        self.set_num_parameter(num_parameters)
        self._is_function_simplextree = False
        self.filtration_grid=[]

    def __dealloc__(self):
        cdef Simplex_tree_multi_interface[{{FSHORT}},{{CTYPE}}]* ptr = self.get_ptr()
        if ptr != NULL:
            del ptr
            # TODO : is that enough ??

    def __repr__(self):
        return f"SimplexTreeMulti[dtype={np.dtype(self.dtype).name},num_param={self.num_parameters},kcritical={self.is_kcritical},is_squeezed={self.is_squeezed},max_dim={self.dimension}]" 
    def __len__(self):
        return self.num_simplices

    def __getstate__(self):
        """:returns: Serialized (or flattened) SimplexTree data structure in order to pickle SimplexTree.
        :rtype: numpy.array of shape (n,)
        """
        cdef size_t buffer_size = self.get_ptr().get_serialization_size()
        # Let's use numpy to allocate a buffer. Will be deleted automatically
        np_buffer = np.empty(buffer_size, dtype='B')
        cdef char[:] buffer = np_buffer
        cdef char* buffer_start = &buffer[0]
        with nogil:
            self.get_ptr().serialize(buffer_start, buffer_size)
        
        return np_buffer
    def __setstate__(self, state):
        """Construct the SimplexTree data structure from a Numpy Array (cf. :func:`~gudhi.SimplexTree.__getstate__`)
        in order to unpickle a SimplexTree.
        
        :param state: Serialized SimplexTree data structure
        :type state: numpy.array of shape (n,)
        """
        cdef char[:] buffer = state
        cdef size_t buffer_size = state.shape[0]
        cdef char* buffer_start = &buffer[0]
        with nogil:
            # deserialization requires an empty SimplexTree
            self.get_ptr().clear()
            # New pointer is a deserialized simplex tree
            self.get_ptr().deserialize(buffer_start, buffer_size)


    def copy(self)->SimplexTreeMulti_{{FSHORT}}:
        """
        :returns: A simplex tree that is a deep copy of itself.
        :rtype: SimplexTreeMulti

        :note: The persistence information is not copied. If you need it in the clone, you have to call
            :func:`compute_persistence` on it even if you had already computed it in the original.
        """
        stree = SimplexTreeMulti_{{FSHORT}}(self,num_parameters=self.num_parameters)
        stree.filtration_grid = self.filtration_grid
        stree._is_function_simplextree  = self._is_function_simplextree
        return stree

    def __deepcopy__(self):
        return self.copy()

    def filtration(self, simplex:list|np.ndarray)->np.ndarray:
        """This function returns the filtration value for a given N-simplex in
        this simplicial complex, or +infinity if it is not in the complex.
        :param simplex: The N-simplex, represented by a list of vertex.
        :type simplex: list of int
        :returns:  The simplicial complex multi-critical filtration value.
        :rtype:  numpy array of shape (-1, num_parameters)
        """
        return self[simplex]

    def assign_filtration(self, simplex:list|np.ndarray, filtration:list|np.ndarray)->SimplexTreeMulti_{{FSHORT}}:
        """This function assigns a new multi-critical filtration value to a
        given N-simplex.

        :param simplex: The N-simplex, represented by a list of vertex.
        :type simplex: list of int
        :param filtration:  The new filtration(s) value(s), concatenated.
        :type filtration:  list[float] or np.ndarray[float, ndim=1]

        .. note::
            Beware that after this operation, the structure may not be a valid
            filtration anymore, a simplex could have a lower filtration value
            than one of its faces. Callers are responsible for fixing this
            (with more :meth:`assign_filtration` or
             :meth:`make_filtration_non_decreasing` for instance) before calling
            any function that relies on the filtration property, like
            :meth:`persistence`.
        """
        assert len(filtration)>0 and len(filtration) % self.get_ptr().get_number_of_parameters() == 0
        # self.get_ptr().assign_simplex_filtration(simplex, {{FSHORT}}(<python_filtration_type>filtration))
        {{if is_kcritical}}
        filtration = np.asarray(filtration, dtype={{PYTYPE}})[None,:]
        self.get_ptr().assign_simplex_filtration(simplex, _py2kc_{{SHORT}}(filtration))
        {{else}}
        filtration = np.asarray(filtration, dtype={{PYTYPE}})
        self.get_ptr().assign_simplex_filtration(simplex, _py21c_{{SHORT}}(filtration))
        {{endif}}
        return self

    def __getitem__(self, simplex)->np.ndarray:
        cdef vector[int] csimplex = simplex 
        cdef {{FSHORT}}* f_ptr = self.get_ptr().simplex_filtration(csimplex)
        {{if is_kcritical}}
        return _ff2kcview_{{SHORT}}(f_ptr)
        {{else}}
        return _ff21cview_{{SHORT}}(f_ptr)
        {{endif}}


    @property
    def num_vertices(self)->int:
        """This function returns the number of vertices of the simplicial
        complex.

        :returns:  The simplicial complex number of vertices.
        :rtype:  int
        """
        return self.get_ptr().num_vertices()

    @property
    def num_simplices(self)->int:
        """This function returns the number of simplices of the simplicial
        complex.

        :returns:  the simplicial complex number of simplices.
        :rtype:  int
        """
        return self.get_ptr().num_simplices()

    @property
    def dimension(self)->int:
        """This function returns the dimension of the simplicial complex.

        :returns:  the simplicial complex dimension.
        :rtype:  int

        .. note::

            This function is not constant time because it can recompute
            dimension if required (can be triggered by
            :func:`remove_maximal_simplex`
            or
            :func:`prune_above_filtration`
            methods).
        """
        return self.get_ptr().dimension()
    def upper_bound_dimension(self)->int:
        """This function returns a valid dimension upper bound of the
        simplicial complex.

        :returns:  an upper bound on the dimension of the simplicial complex.
        :rtype:  int
        """
        return self.get_ptr().upper_bound_dimension()

    def __iter__(self):
      for stuff in self.get_simplices():
        yield stuff

    def flagify(self, const int dim=2):
        """
        Turns this simplicial complex into a flag
        complex by resetting filtration values of
        simplices of dimension > `dim` by 
        lower-star values.
        """
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()

        cdef One_critical_filtration[{{CTYPE}}] minf = One_critical_filtration[{{CTYPE}}](self.get_ptr().get_number_of_parameters())
        cdef int simplex_dimension
        with nogil:
            while it != end:
                pair_sf =<pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))
                simplex_dimension = <int>(pair_sf.first.size())-1
                if simplex_dimension<dim:
                  preincrement(it)
                  continue
                dereference(pair_sf.second).pull_to_greatest_common_lower_bound(minf)
                preincrement(it)
        self.make_filtration_non_decreasing()
        return self

    def set_dimension(self, int dimension)->None:
        """This function sets the dimension of the simplicial complex.

        :param dimension: The new dimension value.
        :type dimension: int

        .. note::

            This function must be used with caution because it disables
            dimension recomputation when required
            (this recomputation can be triggered by
            :func:`remove_maximal_simplex`
            or
            :func:`prune_above_filtration`
            ).
        """
        self.get_ptr().set_dimension(dimension)

    def __contains__(self, simplex):
        """This function returns if the N-simplex was found in the simplicial
        complex or not.

        :param simplex: The N-simplex to find, represented by a list of vertex.
        :type simplex: list of int
        :returns:  true if the simplex was found, false otherwise.
        :rtype:  bool
        """
        if len(simplex) == 0:
          return False
        if isinstance(simplex[0], Iterable):
          s,f = simplex
          if not self.get_ptr().find_simplex(simplex):
            return False
          current_f = np.asarray(self[s])
          return np.all(np.asarray(f)>=current_f)

        return self.get_ptr().find_simplex(simplex)

    def insert(self, vector[int] simplex, filtration:list|np.ndarray|None=None)->bool:
        """This function inserts the given N-simplex and its subfaces with the
        given filtration value (default value is '0.0'). If some of those
        simplices are already present with a higher filtration value, their
        filtration value is lowered.

        :param simplex: The N-simplex to insert, represented by a list of
            vertex.
        :type simplex: list of int
        :param filtration: The filtration value of the simplex.
        :type filtration: float
        :returns:  true if the simplex was not yet in the complex, false
            otherwise (whatever its original filtration value).
        :rtype:  bool
        """
        # TODO C++, to be compatible with insert_batch and multicritical filtrations
        num_parameters = self.get_ptr().get_number_of_parameters()
        assert filtration is None or len(filtration) % num_parameters == 0, f"Invalid number \
                of parameters. Should be {num_parameters}, got {len(filtration)}"
        if filtration is None:
            filtration = np.array([-np.inf]*num_parameters, dtype = float)

        filtration = np.asarray(filtration, dtype = {{PYTYPE}})

        {{if is_kcritical}}
        from itertools import chain, combinations

        def powerset(iterable):
            s = tuple(iterable)
            return chain.from_iterable(combinations(s, r) for r in range(1,len(s)+1)) # skip the empty splx
        cdef {{FSHORT}}* current_filtration_ptr
        cdef vector[vector[int]] simplices_filtration_to_insert = powerset(simplex) # TODO : optimize

        if self.get_ptr().find_simplex(simplex):
          for i in range(simplices_filtration_to_insert.size()):
            current_filtration_ptr = self.get_ptr().simplex_filtration(simplices_filtration_to_insert[i])
            dereference(current_filtration_ptr).add_generator(_py21c_{{SHORT}}(filtration))
          return True ## TODO : we may want to return false if this birth wasn't necessary
        cdef {{Filtration}} cfiltration = _py2kc_{{SHORT}}(filtration[None,:])
        {{else}}
        cdef {{Filtration}} cfiltration = _py21c_{{SHORT}}(filtration)
        {{endif}}
        return self.get_ptr().insert(simplex,cfiltration)

    {{if not is_kcritical}}
    @cython.boundscheck(False)
    @cython.wraparound(False)
    def insert_batch(self,  vertex_array,  filtrations)->SimplexTreeMulti_{{FSHORT}} :
        """Inserts k-simplices given by a sparse array in a format similar
        to `torch.sparse <https://pytorch.org/docs/stable/sparse.html>`_.
        The n-th simplex has vertices `vertex_array[0,n]`, ...,
        `vertex_array[k,n]` and filtration value `filtrations[n,num_parameters]`.
        /!\ Only compatible with 1-critical filtrations. If a simplex is repeated, 
        only one filtration value will be taken into account.

        :param vertex_array: the k-simplices to insert.
        :type vertex_array: numpy.array of shape (k+1,n)
        :param filtrations: the filtration values.
        :type filtrations: numpy.array of shape (n,num_parameters)
        """
        # TODO : multi-critical
        # cdef vector[int] vertices = np.unique(vertex_array)
        cdef int[:,:] vertex_array_ = np.asarray(vertex_array, dtype=np.int32)
        cdef Py_ssize_t k = vertex_array_.shape[0]
        cdef Py_ssize_t n = vertex_array_.shape[1]
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()    
        cdef bool empty_filtration = (filtrations.size == 0)
        cdef {{CTYPE}}[:,:] F_view = np.asarray(filtrations, dtype = {{PYTYPE}})

        if not empty_filtration :
            assert filtrations.shape[0] == n, f"inconsistent sizes for vertex_array and filtrations\
                    Filtrations should be of shape ({n},{self.num_parameters})"
            assert filtrations.shape[1] == num_parameters, f"Inconsistent number of parameters.\
                    Filtrations should be of shape ({n},{self.num_parameters})"
        cdef Py_ssize_t i
        cdef Py_ssize_t j
        cdef vector[int] v
        cdef {{Filtration}} w
        if empty_filtration:
            w = One_critical_filtration[{{CTYPE}}](num_parameters) # at -inf by default
        with nogil:
            for i in range(n):
                # vertex
                for j in range(k):
                    v.push_back(vertex_array_[j, i])
                #filtration
                if not empty_filtration:
                    # for j in range(num_parameters):
                    #     w.push_back(<{{CTYPE}}>filtrations[i,j])
                    w = _py21c_{{SHORT}}(F_view[i,:])
                self.get_ptr().insert(v, w)
                v.clear()
        #repair filtration if necessary
        if empty_filtration:
            self.make_filtration_non_decreasing()
        return self

    def lower_star_multi_filtration_update(self, nodes_filtrations):
        """
        Updates the multi filtration of the simplextree to the lower-star
        filtration defined on the vertices, by `node_filtrations`.
        """
        cdef Py_ssize_t num_vertices = nodes_filtrations.shape[0]
        cdef Py_ssize_t num_parameters = nodes_filtrations.shape[1]
        assert self.get_ptr().get_number_of_parameters() == num_parameters and self.num_vertices == num_vertices, f"Invalid shape {nodes_filtrations.shape}. Should be (?,{self.num_parameters=})."

        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()
        cdef Py_ssize_t node_idx = 0
        cdef {{CTYPE}}[:,:] F = nodes_filtrations
        cdef {{CTYPE}} minus_inf = -np.inf
        with nogil:
            while it != end:
                pair_sf = <pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))
                if pair_sf.first.size() == 1: # dimension == 0
                    {{if is_kcritical}}
                    for i in range(pair_sf.second.size()):
                        for j in range(num_parameters):
                            dereference(pair_sf.second)[i][j] = F[node_idx,j]
                    {{else}}
                    for i in range(num_parameters):
                        dereference(pair_sf.second)[i] = F[node_idx,i]
                    {{endif}}
                    node_idx += 1
                    # with gil:
                    #   print(pair_sf.first, node_idx,i, F[node_idx,i])
                else:
                    {{if is_kcritical}}
                    for i in range(pair_sf.second.size()):
                        for j in range(num_parameters):
                            dereference(pair_sf.second)[i][j] = minus_inf
                    {{else}}
                    for i in range(num_parameters):
                        dereference(pair_sf.second)[i] = minus_inf
                    {{endif}}
                preincrement(it)
        self.make_filtration_non_decreasing()
        return self


    def assign_all(self, filtration_values)-> SimplexTreeMulti_{{FSHORT}}:
        """
        Updates the filtration values of all of the simplices, with `filtration_values`
        with order given by the simplextree iterator, e.g. self.get_simplices().
        """
        cdef Py_ssize_t num_simplices = filtration_values.shape[0] 
        cdef Py_ssize_t num_parameters = filtration_values.shape[1]

        assert num_simplices == self.num_simplices, f"Number of filtration values {filtration_values.shape[0]} is not the number of simplices {self.num_simplices}"
        assert num_parameters == self.num_parameters, f"Number of parameter do not coincide {filtration_values.shape[1]} vs {self.num_parameters}"
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()
        cdef Simplex_tree_multi_simplex_handle[{{FSHORT}}] sh = dereference(it)
        cdef int counter =0
        # cdef cnp.ndarray[{{CTYPE}},ndim=1] current_filtration
        cdef {{CTYPE}}[:,:] F = filtration_values 
        with nogil:
            while it != end:
                pair_sf =<pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))

                for i in range(num_parameters):
                    dereference(pair_sf.second)[i] = F[counter,i]
                # current_filtration= F[counter]
                counter += 1
                # yield SimplexTreeMulti._pair_simplex_filtration_to_python(out)
                preincrement(it)



    @cython.boundscheck(False)
    @cython.wraparound(False)
    def assign_batch_filtration(self, some_int[:,:] vertex_array, some_float[:,:]  filtrations, bool propagate=True)->SimplexTreeMulti_{{FSHORT}}:
        """Assign k-simplices given by a sparse array in a format similar
        to `torch.sparse <https://pytorch.org/docs/stable/sparse.html>`_.
        The n-th simplex has vertices `vertex_array[0,n]`, ...,
        `vertex_array[k,n]` and filtration value `filtrations[n,num_parameters]`.
        /!\ Only compatible with 1-critical filtrations. If a simplex is repeated, 
        only one filtration value will be taken into account.

        :param vertex_array: the k-simplices to assign.
        :type vertex_array: numpy.array of shape (k+1,n)
        :param filtrations: the filtration values.
        :type filtrations: numpy.array of shape (n,num_parameters)
        """
        cdef Py_ssize_t k = vertex_array.shape[0]
        cdef Py_ssize_t n = vertex_array.shape[1]
        assert filtrations.shape[0] == n, 'inconsistent sizes for vertex_array and filtrations'
        assert filtrations.shape[1] == self.num_parameters, "wrong number of parameters"
        cdef Py_ssize_t i
        cdef Py_ssize_t j
        cdef vector[int] v
        cdef One_critical_filtration[{{CTYPE}}] w
        cdef int n_parameters = self.num_parameters
        with nogil:
            for i in range(n):
                for j in range(k):
                    v.push_back(vertex_array[j, i])
                for j in range(n_parameters):
                    w.push_back(<{{CTYPE}}>filtrations[i,j])
                self.get_ptr().assign_simplex_filtration(v, w)
                v.clear()
                w.clear()
        if propagate: self.make_filtration_non_decreasing()
        return self

    def euler_characteristic(self, dtype = {{PYTYPE}}):
        """This function returns a generator with simplices and their given
        filtration values.

        :returns:  The simplices.
        :rtype:  generator with tuples(simplex, filtration)
        """
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()
        cdef Simplex_tree_multi_simplex_handle[{{FSHORT}}] sh = dereference(it)
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()
        cdef dict[tuple,int] out = {}
        cdef int dim
        while it != end:
            pair_sf = <pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))
            # TODO: optimize https://stackoverflow.com/questions/16589791/most-efficient-property-to-hash-for-numpy-array
            key = tuple(_ff21cview_{{SHORT}}(pair_sf.second))
            dim = pair_sf.first.size() -1 % 2
            out[key] = out.get(key,0)+(-1)**dim
        num_keys = len(out)
        new_pts = np.fromiter(out.keys(), dtype=np.dtype((dtype,num_parameters)), count=num_keys) 
        new_weights = np.fromiter(out.values(), dtype=np.int32, count=num_keys)
        idx = np.nonzero(new_weights)
        new_pts = new_pts[idx]
        new_weights = new_weights[idx]
        return (new_pts, new_weights)
    
    {{else}}

    @cython.boundscheck(False)
    @cython.wraparound(False)
    def insert_batch(self, vertex_array, filtrations)->SimplexTreeMulti_{{FSHORT}} :
        """Inserts k-simplices given by a sparse array in a format similar
        to `torch.sparse <https://pytorch.org/docs/stable/sparse.html>`_.
        The i-th simplex has vertices `vertex_array[0,i]`, ...,
        `vertex_array[n,i]` and j-th filtration value `filtrations[i,j,num_parameters]`.

        :param vertex_array: the k-simplices to insert.
        :type vertex_array: numpy.array of shape (k+1,n)
        :param filtrations: the filtration values.
        :type filtrations: numpy.array of shape (n, max_critical_degree, num_parameters)
        """
        # TODO : multi-critical
        # cdef vector[int] vertices = np.unique(vertex_array)

        cdef int[:,:] vertex_array_ = np.asarray(vertex_array, dtype=np.int32) 
        cdef {{CTYPE}}[:,:,:] filtrations_ = np.asarray(filtrations, dtype={{PYTYPE}}) 
        cdef Py_ssize_t k = vertex_array_.shape[0]
        cdef Py_ssize_t n = vertex_array_.shape[1]
        cdef Py_ssize_t max_crit_deg = filtrations_.shape[1]
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()    
        cdef bool empty_filtration = (filtrations_.size == 0)

        if not empty_filtration :
            assert filtrations_.shape[0] == n and filtrations_.shape[2] == num_parameters, f"""
            Inconsistent sizes for vertex_array and filtrations\n
            Filtrations should be of shape ({n},k, {self.num_parameters})
            """
        cdef Py_ssize_t i
        cdef Py_ssize_t j
        cdef vector[int] v
        cdef One_critical_filtration[{{CTYPE}}] w_temp
        cdef {{Filtration}} w
        if empty_filtration:
            w = {{Filtration}}() # at -inf by default
        with nogil:
            for i in range(n):
                v.clear()
                # vertex
                for j in range(k):
                    v.push_back(vertex_array_[j, i])
                #filtration
                if not empty_filtration:
                    w =  _py2kc_{{SHORT}}(filtrations_[i])
                self.get_ptr().insert(v, w)

        #repair filtration if necessary
        if empty_filtration:
            self.make_filtration_non_decreasing()
        return self
    {{endif}}


    def get_simplices(self)->Iterable[tuple[np.ndarray, np.ndarray]]:
        """This function returns a generator with simplices and their given
        filtration values.

        :returns:  The simplices.
        :rtype:  generator with tuples(simplex, filtration)
        """
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()
        cdef Simplex_tree_multi_simplex_handle[{{FSHORT}}] sh = dereference(it)
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()
        while it != end:
            pair_sf = <pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))
            yield (
              np.asarray(pair_sf.first, dtype=int),
           {{if is_kcritical}}
            _ff2kcview_{{SHORT}}(pair_sf.second)
            {{else}}
            _ff21cview_{{SHORT}}(pair_sf.second)
            {{endif}}
            )
            preincrement(it)


    def _get_raw_filtration(self):
       {{if is_kcritical}}
       raise NotImplementedError("Not implemented for multicritical filtrations")
       {{else}}
        if self.is_squeezed:
            raise NotImplementedError("Not implemented for squeezed filtrations")
        cdef int num_parameters = self.num_parameters
        cdef {{CTYPE}}[:,:] current_filtration = np.empty((self.num_simplices, self.num_parameters), dtype=self.dtype)

        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] it = self.get_ptr().get_simplices_iterator_begin()
        cdef Simplex_tree_multi_simplices_iterator[{{FSHORT}}] end = self.get_ptr().get_simplices_iterator_end()

        cdef int i=0
        with nogil:
            while it != end:
                pair_sf = <pair[simplex_type, {{FSHORT}}*]> self.get_ptr().get_simplex_and_filtration(dereference(it))
                for j in range(num_parameters):
                    current_filtration[i,j] = dereference(pair_sf.second)[j]
                preincrement(it)
                i = i+1
        return np.asarray(current_filtration, dtype=self.dtype)
        {{endif}}



    def get_skeleton(self, dimension)->Iterable[tuple[np.ndarray,np.ndarray]]:
        """This function returns a generator with the (simplices of the) skeleton of a maximum given dimension.

        :param dimension: The skeleton dimension value.
        :type dimension: int
        :returns:  The (simplices of the) skeleton of a maximum dimension.
        :rtype:  generator with tuples(simplex, filtration)
        """
        cdef Simplex_tree_multi_skeleton_iterator[{{FSHORT}}] it = self.get_ptr().get_skeleton_iterator_begin(dimension)
        cdef Simplex_tree_multi_skeleton_iterator[{{FSHORT}}] end = self.get_ptr().get_skeleton_iterator_end(dimension)
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()
        while it != end:
            # yield self.get_ptr().get_simplex_and_filtration(dereference(it))
            pair = self.get_ptr().get_simplex_and_filtration(dereference(it))
            yield (np.asarray(pair.first, dtype=int),
            {{if is_kcritical}}
            _ff2kcview_{{SHORT}}(pair.second)
            {{else}}
            _ff21cview_{{SHORT}}(pair.second)
            {{endif}}
            )
            preincrement(it)

   #  def get_star(self, simplex):
   #      """This function returns the star of a given N-simplex.

   #      :param simplex: The N-simplex, represented by a list of vertex.
   #      :type simplex: list of int
   #      :returns:  The (simplices of the) star of a simplex.
   #      :rtype:  list of tuples(simplex, filtration)
   #      """
   #      cdef simplex_type csimplex = simplex
   #      cdef int num_parameters = self.num_parameters
   #      # for i in simplex:
   #      #   csimplex.push_back(i)
   #      cdef vector[simplex_filtration_type] star \
   #              = self.get_ptr().get_star(csimplex)
   #      ct = []

   #      for filtered_simplex in star:
   #          v = []
   #          for vertex in filtered_simplex.first:
   #              v.append(vertex)
   #          ct.append((v, np.asarray(<{{CTYPE}}[:num_parameters]>filtered_simplex.second)))
   #      return ct

    # def get_cofaces(self, simplex, codimension):
    #     """This function returns the cofaces of a given N-simplex with a
    #     given codimension.

    #     :param simplex: The N-simplex, represented by a list of vertex.
    #     :type simplex: list of int
    #     :param codimension: The codimension. If codimension = 0, all cofaces
    #         are returned (equivalent of get_star function)
    #     :type codimension: int
    #     :returns:  The (simplices of the) cofaces of a simplex
    #     :rtype:  list of tuples(simplex, filtration)
    #     """
    #     cdef vector[int] csimplex = simplex
    #     cdef int num_parameters = self.num_parameters
    #     # for i in simplex:
    #     #   csimplex.push_back(i)
    #     cdef vector[simplex_filtration_type] cofaces \
    #             = self.get_ptr().get_cofaces(csimplex, <int>codimension)
    #     ct = []
    #     for filtered_simplex in cofaces:
    #         v = []
    #         for vertex in filtered_simplex.first:
    #             v.append(vertex)
    #         ct.append((v, np.asarray(<{{CTYPE}}[:num_parameters]>filtered_simplex.second)))
    #     return ct

    def get_boundaries(self, simplex)->Iterable[tuple[np.ndarray, np.ndarray]]:
        """This function returns a generator with the boundaries of a given N-simplex.
        If you do not need the filtration values, the boundary can also be obtained as
        :code:`itertools.combinations(simplex,len(simplex)-1)`.

        :param simplex: The N-simplex, represented by a list of vertex.
        :type simplex: list of int.
        :returns:  The (simplices of the) boundary of a simplex
        :rtype:  generator with tuples(simplex, filtration)
        """
        cdef pair[Simplex_tree_multi_boundary_iterator[{{FSHORT}}], Simplex_tree_multi_boundary_iterator[{{FSHORT}}]] it =  self.get_ptr().get_boundary_iterators(simplex)

        cdef int num_parameters = self.get_ptr().get_number_of_parameters()
        while it.first != it.second:
            # yield self.get_ptr().get_simplex_and_filtration(dereference(it))
            pair = self.get_ptr().get_simplex_and_filtration(dereference(it.first))
            yield (np.asarray(pair.first, dtype=int),
            {{if is_kcritical}}
            _ff2kcview_{{SHORT}}(pair.second)
            {{else}}
            _ff21cview_{{SHORT}}(pair.second)
            {{endif}}
            )
            preincrement(it.first)
    def remove_maximal_simplex(self, simplex)->SimplexTreeMulti_{{FSHORT}}:
        """This function removes a given maximal N-simplex from the simplicial
        complex.

        :param simplex: The N-simplex, represented by a list of vertex.
        :type simplex: list of int

        .. note::

            The dimension of the simplicial complex may be lower after calling
            remove_maximal_simplex than it was before. However,
            :func:`upper_bound_dimension`
            method will return the old value, which
            remains a valid upper bound. If you care, you can call
            :func:`dimension`
            to recompute the exact dimension.
        """
        self.get_ptr().remove_maximal_simplex(simplex)
        return self

    # def prune_above_filtration(self, filtration)->bool:
    #   """Prune above filtration value given as parameter.

    #   :param filtration: Maximum threshold value.
    #   :type filtration: float
    #   :returns: The filtration modification information.
    #   :rtype: bool


    #   .. note::

    #     Note that the dimension of the simplicial complex may be lower
    #     after calling
    #     :func:`prune_above_filtration`
    #     than it was before. However,
    #     :func:`upper_bound_dimension`
    #     will return the old value, which remains a
    #     valid upper bound. If you care, you can call
    #     :func:`dimension`
    #     method to recompute the exact dimension.
    #   """
    #   return self.get_ptr().prune_above_filtration(filtration)
    def prune_above_dimension(self, int dimension):
        """Remove all simplices of dimension greater than a given value.

        :param dimension: Maximum dimension value.
        :type dimension: int
        :returns: The modification information.
        :rtype: bool
        """
        return self.get_ptr().prune_above_dimension(dimension)

    def expansion(self, int max_dim)->SimplexTreeMulti_{{FSHORT}}:
        """Expands the simplex tree containing only its one skeleton
        until dimension max_dim.

        The expanded simplicial complex until dimension :math:`d`
        attached to a graph :math:`G` is the maximal simplicial complex of
        dimension at most :math:`d` admitting the graph :math:`G` as
        :math:`1`-skeleton.
        The filtration value assigned to a simplex is the maximal filtration
        value of one of its edges.

        The simplex tree must contain no simplex of dimension bigger than
        1 when calling the method.

        :param max_dim: The maximal dimension.
        :type max_dim: int
        """
        with nogil:
            self.get_ptr().expansion(max_dim)
            # This is a fix for multipersistence. FIXME expansion in c++
            self.get_ptr().make_filtration_non_decreasing()
        return self

    def make_filtration_non_decreasing(self)->bool: 
        """This function ensures that each simplex has a higher filtration
        value than its faces by increasing the filtration values.

        :returns: True if any filtration value was modified,
            False if the filtration was already non-decreasing.
        :rtype: bool
        """
        cdef bool out
        with nogil:
            out = self.get_ptr().make_filtration_non_decreasing()
        return out

    def reset_filtration(self, filtration, min_dim = 0)->SimplexTreeMulti_{{FSHORT}}:
        """This function resets the filtration value of all the simplices of dimension at least min_dim. Resets all the
        simplex tree when `min_dim = 0`.
        `reset_filtration` may break the filtration property with `min_dim > 0`, and it is the user's responsibility to
        make it a valid filtration (using a large enough `filt_value`, or calling `make_filtration_non_decreasing`
        afterwards for instance).

        :param filtration: New threshold value.
        :type filtration: float.
        :param min_dim: The minimal dimension. Default value is 0.
        :type min_dim: int.
        """
        {{if is_kcritical}}
        cdef {{Filtration}} cfiltration = _py2kc_{{SHORT}}(np.asarray(filtration, dtype = {{PYTYPE}})[None,:])
        {{else}}
        cdef {{Filtration}} cfiltration = _py21c_{{SHORT}}(np.asarray(filtration, dtype = {{PYTYPE}}))
        {{endif}}
        self.get_ptr().reset_filtration(cfiltration, min_dim)
        return self

    {{if not is_kcritical}}
    def pts_to_indices(self,pts:np.ndarray, simplices_dimensions:Iterable[int]) -> tuple[np.ndarray,np.ndarray]:
        """
        Returns the indices of the simplex tree with corresponding filtrations.

        Args:
         - st: SimplexTreeMulti on which to recover the indices.
         - pts: (num_pts, num_parameters,) array of points to recover.
            simplices_dimensions: (num_parameters,) the simplices dimension to take into account for each parameter.

        Returns:
         - A (m, num_parameters) array containing the found indices (m <= num_pts).
         - A (m, 2) array containing the non-found indices (pt_index, parameter failing).
        """

        # TODO detect rank or not
        cdef bool is_rank_invariant = pts.shape[1] == 2*self.num_parameters
        if is_rank_invariant:
            births = pts[:,:self.num_parameters]
            deaths = pts[:,self.num_parameters:]
            births_indices,non_recovered_births  = self.pts_to_indices(births, simplices_dimensions)
            deaths_indices,non_recovered_deaths = self.pts_to_indices(deaths, simplices_dimensions)
            non_recovered_pts = np.concatenate([non_recovered_births,non_recovered_deaths], axis=0)
            pts_indices = np.concatenate([births_indices,deaths_indices], axis=1)
            return pts_indices, non_recovered_pts

        cdef vector[vector[{{CTYPE}}]] cpts = pts
        cdef vector[int] csimplices_dimensions = simplices_dimensions
        # cdef pair[indices_type,indices_type] out
        found_indices,not_found_indices = self.get_ptr().pts_to_indices(cpts,csimplices_dimensions)
        if len(found_indices) == 0:
            found_indices = np.empty(shape=(0,self.num_parameters), dtype = np.int32)
        if len(not_found_indices) == 0:
            not_found_indices =  np.empty(shape=(0,2), dtype = np.int32)
        return np.asarray(found_indices), np.asarray(not_found_indices)
    ## This function is only meant for the edge collapse interface.
    def get_edge_list(self):
        """
        in the filtration-domination's format       
        """
        cdef edge_list out
        with nogil:
            out = self.get_ptr().get_edge_list()
        return out

    def collapse_edges(
            self,
            int num=1,
            int max_dimension = 0,
            bool progress=False,
            bool strong=True,
            bool full=False,
            bool ignore_warning=False,
            bool auto_clean=True,
        )->SimplexTreeMulti_{{FSHORT}}:
        """Edge collapse for 1-critical 2-parameter clique complex (see https://arxiv.org/abs/2211.05574).
        It uses the code from the github repository https://github.com/aj-alonso/filtration_domination .

        Parameters
        ----------
        
        max_dimension:int
            Max simplicial dimension of the complex. Unless specified, keeps the same dimension.
        num:int
            The number of collapses to do.
        strong:bool
            Whether to use strong collapses or standard collapses (slower, but may remove more edges)
        full:bool
            Collapses the maximum number of edges if true, i.e., will do (at most) 100 strong collapses and (at most) 100 non-strong collapses afterward.
        progress:bool
            If true, shows the progress of the number of collapses.

        WARNING
        -------
        
         - This will destroy all of the k-simplices, with k>=2. Be sure to use this with a clique complex, if you want to preserve the homology >= dimension 1.
         - This is for 1 critical simplices, with 2 parameter persistence.
        Returns
        -------
        
        self:SimplexTreeMulti
            A (smaller) simplex tree that has the same homology over this bifiltration.

        """
        # TODO : find a way to do multiple edge collapses without python conversions.
        if num == 0:
            return self
        elif num == -1:
            num=100
            full=False
        elif num == -2:
            num=100
            full=True
        assert self.num_parameters == 2, "Number of parameters has to be 2 to use edge collapses ! This is a limitation of Filtration-domination"
        if self.dimension > 1 and not ignore_warning: warn("This method ignores simplices of dimension > 1 !")

        max_dimension = self.dimension if max_dimension <=0 else max_dimension

        # Retrieves the edge list, and send it to filration_domination
        edges = self.get_edge_list()
        from multipers.multiparameter_edge_collapse import _collapse_edge_list
        edges = _collapse_edge_list(edges, num=num, full=full, strong=strong, progress=progress)
        # Retrieves the collapsed simplicial complex
        self._reconstruct_from_edge_list(edges, swap=True, expand_dimension=max_dimension)
        if self.is_squeezed and auto_clean:
            self._clean_filtration_grid()
        return self

    @cython.inline
    cdef _reconstruct_from_edge_list(self,edge_list edges, bool swap=True, int expand_dimension=0):
        """
        Generates a 1-dimensional copy of self, with the edges given as input. Useful for edge collapses

        Input
        -----

         - edges : Iterable[(int,int),(float,float)] ## This is the format of the rust library filtration-domination
         - swap : bool
            If true, will swap self and the collapsed simplextrees.
         - expand_dim : int
            expands back the simplextree to this dimension
        Ouput
        -----
        
        The reduced SimplexTreeMulti having only these edges.
        """
        reduced_tree = SimplexTreeMulti_{{FSHORT}}(num_parameters=self.num_parameters)

        ## Adds vertices back, with good filtration
        if self.num_vertices > 0:
            vertices = np.fromiter((splx[0] for splx, f in self.get_skeleton(0)), dtype=np.int32)[None,:]
            vertices_filtration = np.fromiter((f for splx, f in self.get_skeleton(0)), dtype=np.dtype(({{PYTYPE}},2)))
            reduced_tree.insert_batch(vertices, vertices_filtration)

        ## Adds edges again
        if self.num_simplices - self.num_vertices > 0:
            edges_filtration = np.fromiter(((e.second.first, e.second.second) for e in edges), dtype=np.dtype(({{PYTYPE}},2)))
            edges_idx = np.fromiter(((e.first.first, e.first.second) for e in edges), dtype=np.dtype((np.int32,2))).T
            reduced_tree.insert_batch(edges_idx, edges_filtration)
        if swap:
            # Swaps the simplextrees pointers
            self.thisptr, reduced_tree.thisptr = reduced_tree.thisptr, self.thisptr # Swaps self and reduced tree (self is a local variable)
        if expand_dimension > 0:
            self.expansion(expand_dimension) # Expands back the simplextree to the original dimension.
        return self if swap else reduced_tree
    {{endif}}

    @property
    def num_parameters(self)->int:
        return self.get_ptr().get_number_of_parameters()
    def get_simplices_of_dimension(self, dim:int)->np.ndarray:
        return np.asarray(self.get_ptr().get_simplices_of_dimension(dim), dtype=int)
    def key(self, simplex:list|np.ndarray):
        return self.get_ptr().get_key(simplex)
    def set_keys_to_enumerate(self)->None:
        self.get_ptr().set_keys_to_enumerate()
        return
    def set_key(self,simplex:list|np.ndarray, key:int)->None:
        self.get_ptr().set_key(simplex, key)
        return



    def _to_scc(self,filtration_dtype={{PYTYPE}}, bool flattened=False):
        """
        Turns a simplextree into a (simplicial) module presentation.
        """
        cdef bool is_function_st = self._is_function_simplextree
        
        cdef pair[vector[vector[{{CTYPE}}]], boundary_matrix] out
        if flattened:
            # out = simplextree_to_ordered_bf(cptr)
            out = self.get_ptr().simplextree_to_ordered_bf()
            return np.asarray(out.first,dtype=filtration_dtype), tuple(out.second)
        if is_function_st:
    {{if not is_kcritical}}
            blocks = self.get_ptr().function_simplextree_to_scc()
    {{else}}
            raise Exception("Kcritical cannot be a function simplextree ?? TODO: Fixme")
    {{endif}}
        else:
    {{if not is_kcritical}}
            blocks = self.get_ptr().simplextree_to_scc()
    {{else}}
            blocks = self.get_ptr().kcritical_simplextree_to_scc()
    {{endif}}
        # reduces the space in memory
        if is_function_st:
            blocks = [(tuple(f), tuple(b)) for f,b in blocks[::-1]]
        else:
    {{if not is_kcritical}}
            blocks = [(np.asarray(f,dtype=filtration_dtype), tuple(b)) for f,b in blocks[::-1]] ## presentation is on the other order 
    {{else}}
            blocks = [(tuple(f), tuple(b)) for f,b in blocks[::-1]] ## presentation is on the other order 
    {{endif}}
        return blocks # +[(np.empty(0,dtype=filtration_dtype),[])] ## TODO : investigate

    def to_scc_kcritical(self,
            path:os.PathLike|str, 
            bool rivet_compatible=False, 
            bool strip_comments=False, 
            bool ignore_last_generators=False, 
            bool overwrite=False,
            bool reverse_block=False,
        ):
        """
        TODO: function-simplextree, from squeezed
        """
        from os.path import exists
        from os import remove
        if exists(path):
            if not(overwrite):
                raise Exception(f"The file {path} already exists. Use the `overwrite` flag if you want to overwrite.")
            remove(path)
        # blocks = simplextree2scc(self)
        blocks = self._to_scc()
        from multipers.io import scc2disk
        scc2disk(blocks, 
                path=path, 
                num_parameters=self.num_parameters,
                reverse_block=reverse_block,
                rivet_compatible=rivet_compatible,
                ignore_last_generators=ignore_last_generators,
                strip_comments=strip_comments,
            )

    def to_scc_function_st(self,
                           path="scc_dataset.scc", 
                           bool rivet_compatible=False, 
                           bool strip_comments=False, 
                           bool ignore_last_generators=False, 
                           bool overwrite=False,
                           bool reverse_block=True,
                           ):
        from multipers.io import scc2disk
        from warnings import warn
        warn("This function is not tested yet.")
        from os.path import exists
        from os import remove
        if exists(path):
            if not(overwrite):
                raise Exception(f"The file {path} already exists. Use the `overwrite` flag if you want to overwrite.")
            remove(path)
        stuff = self._to_scc(self)
        if reverse_block:  stuff.reverse()
        cdef int num_parameters = self.num_parameters
        with open(path, "w") as f:
            f.write("scc2020\n") if not rivet_compatible else f.write("firep\n")
            if not strip_comments and not rivet_compatible: f.write("# Number of parameters\n")
            num_parameters = self.num_parameters
            if rivet_compatible:
                assert num_parameters == 2
                f.write("Filtration 1\n")
                f.write("Filtration 2\n")
            else:
                f.write(f"{num_parameters}\n")

            if not strip_comments: f.write("# Sizes of generating sets\n")
            for block in stuff: f.write(f"{len(block[1])} ")
            f.write("\n")

            for i,block in enumerate(stuff):
                if (rivet_compatible or ignore_last_generators) and i == len(stuff)-1: continue
                if not strip_comments: f.write(f"# Block of dimension {len(stuff)-i}\n")
                for filtration, boundary in zip(*block):
                    k = len(filtration)
                    for j in range(k):
                        if filtration[j] != np.inf:
                            line = f"{filtration[j]} {k} ; " + " ".join([str(x) for x in boundary]) +"\n"
                            f.write(line)
    def to_scc(self,**kwargs):
        """
        Returns an scc representation of the simplextree.
        """
        if self._is_function_simplextree:
            return self.to_scc_function_st(**kwargs)
        else:
            return self.to_scc_kcritical(**kwargs)

    def to_rivet(self, path="rivet_dataset.txt", degree:int|None = None, progress:bool=False, overwrite:bool=False, xbins:int|None=None, ybins:int|None=None)->None:
        """ Create a file that can be imported by rivet, representing the filtration of the simplextree.

        Parameters
        ----------
        
        path:str
            path of the file.
        degree:int
            The homological degree to ask rivet to compute.
        progress:bool = True
            Shows the progress bar.
        overwrite:bool = False
            If true, will overwrite the previous file if it already exists.
        """
        ...
        from os.path import exists
        from os import remove
        if exists(path):
            if not(overwrite):
                print(f"The file {path} already exists. Use the `overwrite` flag if you want to overwrite.")
                return
            remove(path)
        file = open(path, "a")
        file.write("# This file was generated by multipers.\n")
        file.write("--datatype bifiltration\n")
        file.write(f"--homology {degree}\n")   if degree is not None else None
        file.write(f"-x {xbins}\n")       if xbins is not None else None
        file.write(f"-y {ybins}\n")       if ybins is not None else None
        file.write("--xlabel time of appearance\n")
        file.write("--ylabel density\n\n")
        from tqdm import tqdm
        with tqdm(total=self.num_simplices, position=0, disable = not(progress), desc="Writing simplex to file") as bar:
            for dim in range(0,self.dimension+1): # Not sure if dimension sort is necessary for rivet. Check ?
                file.write(f"# block of dimension {dim}\n")
                for s,F in self.get_skeleton(dim):
                    if len(s) != dim+1:  continue
                    for i in s:
                        file.write(str(i) + " ")
                    file.write("; ")
                    for f in F:
                        {{if is_kcritical}}
                        for fi in f:
                            file.write(str(fi) + " ")
                        {{else}}
                        file.write(str(f) + " ")
                        {{endif}}
                    file.write("\n")
                    bar.update(1)
        file.close()
        return



    def _get_filtration_values(self, vector[int] degrees, bool inf_to_nan:bool=False, bool return_raw = False)->Iterable[np.ndarray]:
        # cdef vector[int] c_degrees = degrees
        # out = get_filtration_values_from_ptr[{{FSHORT}}](ptr, degrees)
        cdef intptr_t ptr = self.thisptr
        cdef vector[vector[vector[{{CTYPE}}]]] out
        with nogil:
            out = self.get_ptr().get_filtration_values(degrees)
        filtrations_values =  [np.asarray(filtration) for filtration in out]
        # Removes infs
        if inf_to_nan and np.dtype(filtrations_values[0].dtype).kind == 'f':
            for i,f in enumerate(filtrations_values):
                filtrations_values[i][f == np.inf] = np.nan
                filtrations_values[i][f == - np.inf] = np.nan
        return filtrations_values
    def _clean_filtration_grid(self):
        """
        Removes the values in filtration_grid that are not linked to any splx.
        """
        if not self.is_squeezed:
            raise ValueError("No grid to clean.")
        F = self.filtration_grid
        self.filtration_grid=None
        cleaned_coordinates = compute_grid(self)
        new_st = self.grid_squeeze(cleaned_coordinates)

        self.thisptr, new_st.thisptr = new_st.thisptr, self.thisptr
        self.filtration_grid = tuple(f[g] for f,g in zip(F,cleaned_coordinates))
        return self



    def get_filtration_grid(self, resolution:Iterable[int]|None=None, degrees:Iterable[int]|None=None, drop_quantiles:float|tuple=0, grid_strategy:_available_strategies="exact")->Iterable[np.ndarray]:
        """
        Returns a grid over the n-filtration, from the simplextree. Usefull for grid_squeeze. TODO : multicritical

        Parameters
        ----------

            resolution: list[int]
                resolution of the grid, for each parameter
            box=None : pair[list[float]]
                Grid bounds. format : [low bound, high bound]
                If None is given, will use the filtration bounds of the simplextree.
            grid_strategy="regular" : string
                Either "regular", "quantile", or "exact".
        Returns
        -------

            List of filtration values, for each parameter, defining the grid.
        """
        if degrees is None:
            degrees = range(self.dimension+1)


        ## preprocesses the filtration values:
        filtrations_values = np.concatenate(self._get_filtration_values(degrees, inf_to_nan=True), axis=1)
        # removes duplicate + sort (nan at the end)
        filtrations_values = [np.unique(filtration) for filtration in filtrations_values]
        # removes nan
        filtrations_values = [filtration[:-1] if np.isnan(filtration[-1]) else filtration for filtration in filtrations_values]

        return compute_grid(filtrations_values, resolution=resolution,strategy=grid_strategy,drop_quantiles=drop_quantiles)


    def grid_squeeze(
            self,
            filtration_grid:np.ndarray|list|None=None,
            bool coordinate_values=True,
            str strategy:_available_strategies = "exact",
            resolution:Optional[int|list[int]] = None,
            bool coordinates = False,
            grid_strategy=None,
            bool inplace=False,
            **filtration_grid_kwargs
        )->SimplexTreeMulti_{{FSHORT[:-3] + "i32"}} | SimplexTreeMulti_{{FSHORT}}:
        """
        Fit the filtration of the simplextree to a grid.

        :param filtration_grid: The grid on which to squeeze. An example of grid can be given by the `get_filtration_grid` method.
        :type filtration_grid: list[list[float]]
        :param coordinate_values: If true, the filtrations values of the simplices will be set to the coordinate of the filtration grid.
        :type coordinate_values: bool
        """

        if grid_strategy is not None:
            warn("`grid_strategy` is deprecated, use `strategy` instead.",DeprecationWarning)
            strategy=grid_strategy

        if self.is_squeezed:
            warn("(copy warning) Squeezing an already squeezed slicer.")
            temp = self.unsqueeze()
            subgrid = compute_grid(self.filtration_grid, strategy=strategy, resolution=resolution)
            return temp.grid_squeeze(sanitize_grid(subgrid, numpyfy=True), coordinates=coordinates, inplace=inplace)

        #TODO : multi-critical
        if filtration_grid is None:  
            filtration_grid = self.get_filtration_grid(grid_strategy=strategy, resolution=resolution, **filtration_grid_kwargs)
        else:
            filtration_grid = sanitize_grid(filtration_grid)
            if len(filtration_grid) != self.num_parameters:
                raise ValueError(f"Invalid grid to squeeze onto. Got {len(filtration_grid)=} != {self.num_parameters=}.")
        api = api_from_tensor(filtration_grid[0])
        cdef vector[vector[double]] c_filtration_grid = tuple(api.asnumpy(f).astype(np.float64) for f in filtration_grid) # may be faster with loop on views
        if coordinate_values and inplace:
            self.filtration_grid = filtration_grid
        if inplace or not coordinate_values:
          self.get_ptr().squeeze_filtration_inplace(c_filtration_grid, coordinate_values)
        else:
          out = SimplexTreeMulti_{{FSHORT[:-3] + "i32"}}(num_parameters=self.num_parameters)
          self.get_ptr().squeeze_filtration(out.thisptr, c_filtration_grid)
          out.filtration_grid = filtration_grid
          return out
        return self

    def unsqueeze(self, grid=None)->SimplexTreeMulti_{{FSHORT[:-3] + "f64"}}:
        from multipers.grids import sanitize_grid
        grid = self.filtration_grid if grid is None else grid

        cdef vector[vector[double]] cgrid = sanitize_grid(grid, numpyfy=True)
        new_slicer = SimplexTreeMulti_{{FSHORT[:-3] + "f64"}}()
        new_slicer.get_ptr().unsqueeze_filtration(self.thisptr, cgrid)

        return new_slicer

    @property
    def is_squeezed(self)->bool:
        return self.num_vertices > 0 and self.filtration_grid is not None and len(self.filtration_grid)>0 and len(self.filtration_grid[0]) > 0

    @property
    def dtype(self)->type:
      return {{PYTYPE}}
    def filtration_bounds(self, degrees:Iterable[int]|None=None, q:float|tuple=0, split_dimension:bool=False)->np.ndarray:
        """
        Returns the filtrations bounds of the finite filtration values.
        """
        try:
            a,b =q
        except:
            a,b,=q,q
        degrees = range(self.dimension+1) if degrees is None else degrees
        filtrations_values = self._get_filtration_values(degrees, inf_to_nan=True) ## degree, parameter, pt
        boxes = np.array([np.nanquantile(filtration, [a, 1-b], axis=1) for filtration in filtrations_values],dtype=float)
        if split_dimension: return boxes
        return np.asarray([np.nanmin(boxes, axis=(0,1)), np.nanmax(boxes, axis=(0,1))]) # box, birth/death, filtration




    def fill_lowerstar(self,  F, int parameter)->SimplexTreeMulti_{{FSHORT}}:
        """ Fills the `dimension`th filtration by the lower-star filtration defined by F.

        Parameters
        ----------

        F:1d array
            The density over the vertices, that induces a lowerstar filtration.
        parameter:int
            Which filtration parameter to fill. /!\ python starts at 0.

        Returns
        -------
        
        self:SimplexTreeMulti
        """
        # for s, sf in self.get_simplices():
        #   self.assign_filtration(s, [f if i != dimension else np.max(np.array(F)[s]) for i,f in enumerate(sf)])
        # cdef int c_parameter = parameter
        {{if is_kcritical}}
        cdef {{FSHORT}} c_F = _py2kc_{{SHORT}}(np.asarray(F,dtype={{PYTYPE}})[None,:])
        {{else}}
        cdef {{FSHORT}} c_F = _py21c_{{SHORT}}(np.asarray(F,dtype={{PYTYPE}}))
        {{endif}}
        with nogil:
            self.get_ptr().fill_lowerstar(c_F, parameter)
        return self

    def fill_distance_matrix(self, distance_matrix, int parameter, {{CTYPE}} node_value = 0)->SimplexTreeMulti_{{FSHORT}}:
        """
        Fills a specific parameter with a rips filtration with the given matrix. 
        
        Warning. Undefined behaviour if `node_value` is not finite or not
                smaller or equal to `min(distance_matrix)`.

        Parameters:
         - `distance_matrix`: a (N,N) matrix aligned with the vertices keys, i.e., 
             `distance_matrix[i,j]` is the distance between simplices [i] and [j].
         - `node_value`: a float giving the values to the nodes in this filtration.

        Returns
        self. The updated simplextree.
        """
        assert parameter < self.num_parameters, f"This simplextree has only {self.num_parameters} parameters. Cannot fill parameter {parameter}"
        cdef {{CTYPE}}[:,:] c_distance_matrix = np.asarray(distance_matrix,dtype={{PYTYPE}})

        ## Resets the filtration. should be optimizable
        F = np.zeros(shape = self.num_vertices, dtype={{PYTYPE}}) + node_value
        {{if is_kcritical}}
        cdef {{FSHORT}} c_F = _py2kc_{{SHORT}}(F[None,:])
        {{else}}
        cdef {{FSHORT}} c_F = _py21c_{{SHORT}}(F)
        {{endif}}
        
        with nogil:
            self.get_ptr().fill_lowerstar(c_F, parameter)

        ## Fills the matrix in the 1-skeleton
        cdef Simplex_tree_multi_skeleton_iterator[{{FSHORT}}] it = self.get_ptr().get_skeleton_iterator_begin(1)
        cdef Simplex_tree_multi_skeleton_iterator[{{FSHORT}}] end = self.get_ptr().get_skeleton_iterator_end(1)
        cdef int num_parameters = self.get_ptr().get_number_of_parameters()
        cdef int num_generators
        cdef int N = c_distance_matrix.shape[0]
        with nogil:
            while it != end:
                pair = self.get_ptr().get_simplex_and_filtration(dereference(it))
                if pair.first.size() == 2:
                    i = pair.first[0]
                    j = pair.first[1]
                    assert i<N, f"Got vertex {i} which is greater than the matrix's size {c_distance_matrix.shape}."
                    assert j<N, f"Got vertex {j} which is greater than the matrix's size {c_distance_matrix.shape}."

                    {{if is_kcritical}}
                    num_generators =pair.second.num_generators() 
                    for k in range(num_generators):
                        dereference(pair.second)[k][parameter] = c_distance_matrix[i,j]
                    {{else}}
                    dereference(pair.second)[parameter] = c_distance_matrix[i,j]
                    {{endif}}
                preincrement(it)

        self.make_filtration_non_decreasing()        
        return self


        


    def project_on_line(self, parameter:int=0, basepoint:None|list|np.ndarray= None, direction:None|list|np.ndarray= None)->SimplexTree:
        """Converts an multi simplextree to a gudhi simplextree.
        
        Parameters
        ----------
        
        parameter:int = 0
            The parameter to keep. WARNING will crash if the multi simplextree is not well filled.
        basepoint:None
            Instead of keeping a single parameter, will consider the filtration defined by the diagonal line crossing the basepoint.
        
        WARNING 
        -------
        
        There are no safeguard yet, it WILL crash if asking for a parameter that is not filled.
        
        Returns
        -------
        
        A SimplexTree with chosen 1D filtration.
        """
        # FIXME : deal with multicritical filtrations
        import gudhi as gd
        new_simplextree = gd.SimplexTree()
        assert parameter < self.get_ptr().get_number_of_parameters()
        cdef int c_parameter = parameter
        cdef intptr_t old_ptr = self.thisptr
        cdef intptr_t new_ptr = new_simplextree.thisptr
        if basepoint is None:
          basepoint = np.array([np.inf]*self.get_ptr().get_number_of_parameters())
          basepoint[parameter] = 0
        if direction is None:
          direction = np.array([0]*self.get_ptr().get_number_of_parameters())
          direction[parameter] = 1
        
        basepoint = np.asarray(basepoint, dtype=np.float64)
        direction = np.asarray(direction, dtype=np.float64)
        cdef One_critical_filtration[double] c_basepoint = _py21c_f64(basepoint)
        cdef One_critical_filtration[double] c_direction = _py21c_f64(direction)
        cdef Line[double] c_line = Line[double](c_basepoint, c_direction)
        with nogil:
            self.get_ptr().to_std(new_ptr, c_line, c_parameter)
        return new_simplextree

    def linear_projections(self, linear_forms:np.ndarray)->Iterable[SimplexTree]:
        """
        Compute the 1-parameter projections, w.r.t. given the linear forms, of this simplextree.

        Input
        -----
        
         Array of shape (num_linear_forms, num_parameters)

        Output
        ------
        
        List of projected (gudhi) simplextrees.
        """
        cdef Py_ssize_t num_projections = linear_forms.shape[0]
        cdef Py_ssize_t num_parameters = linear_forms.shape[1]
        if num_projections == 0:  return []
        cdef vector[vector[double]] c_linear_forms = linear_forms
        assert num_parameters==self.num_parameters, f"The linear forms has to have the same number of parameter as the simplextree ({self.num_parameters})."

        # Gudhi copies are faster than inserting simplices one by one
        import gudhi as gd
        # flattened_simplextree = gd.SimplexTree()
        # cdef intptr_t multi_prt = self.thisptr
        # cdef intptr_t flattened_ptr = flattened_simplextree.thisptr
        # with nogil:
        #     # flatten_from_ptr(multi_prt, flattened_ptr, num_parameters)
        #     self.get_ptr().to_std(flattened_ptr, num_parameters)
        flattened_simplextree = self.project_on_line()
        out = [flattened_simplextree] + [gd.SimplexTree(flattened_simplextree) for _ in range(num_projections-1)]

        # Fills the 1-parameter simplextrees.
        cdef vector[intptr_t] out_ptrs = [st.thisptr for st in out]
        with nogil:
            for i in range(num_projections):
                self.get_ptr().to_std_linear_projection(out_ptrs[i], c_linear_forms[i])
        return out


    def set_num_parameter(self, num:int):
        """
        Sets the numbers of parameters. 
        WARNING : it will resize all the filtrations to this size. 
        """
        self.get_ptr().resize_all_filtrations(num)
        self.get_ptr().set_number_of_parameters(num)
        return

    def __eq__(self, other:SimplexTreeMulti_{{FSHORT}}):
        """Test for structural equality
        :returns: True if the 2 simplex trees are equal, False otherwise.
        :rtype: bool
        """
        return dereference(self.get_ptr()) == dereference(other.get_ptr())





# def _simplextree_multify_{{FSHORT}}(simplextree:SimplexTree, int num_parameters, default_values=[])->SimplexTreeMulti_{{FSHORT}}:
#     """Converts a gudhi simplextree to a multi simplextree.
#     Parameters
#     ----------

#     parameters:int = 2
#         The number of filtrations

#     Returns
#     -------

#         A multi simplextree, with first filtration value being the one from the original simplextree.
#     """
#     if isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
#         return simplextree
#     st = SimplexTreeMulti_{{FSHORT}}(num_parameters=num_parameters)
#     cdef intptr_t old_ptr = simplextree.thisptr
#     {{if is_kcritical}}
#     cdef {{FSHORT}} c_default_values= _py2kc_{{SHORT}}([default_values])
#     {{else}}
#     cdef {{FSHORT}} c_default_values= _py21c_{{SHORT}}([default_values])
#     {{endif}}
#     with nogil:
#         st.get_ptr().from_std(old_ptr, num_parameters, c_default_values)
#     return st

@cython.boundscheck(False)
@cython.wraparound(False)
def _safe_simplextree_multify_{{FSHORT}}(simplextree:SimplexTree,int num_parameters=2, cnp.ndarray default_values=np.array(-np.inf))->SimplexTreeMulti_{{FSHORT}}:
    if isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
        return simplextree
    simplices = [[] for _ in range(simplextree.dimension()+1)]
    filtration_values = [[] for _ in range(simplextree.dimension()+1)]
    st_multi = SimplexTreeMulti_{{FSHORT}}(num_parameters=1)
    if num_parameters > 1:
        st_multi.set_num_parameter(num_parameters)
    if default_values.squeeze().ndim == 0:
        default_values = np.zeros(num_parameters-1) + default_values

    # TODO : Optimize with Python.h
    for s,f in simplextree.get_simplices():
        filtration_values[len(s)-1].append(np.concatenate([[f],default_values]))
        simplices[len(s)-1].append(s)
    for batch_simplices, batch_filtrations in zip(simplices,filtration_values):
        st_multi.insert_batch(np.asarray(batch_simplices, dtype=np.int32).T, np.asarray(batch_filtrations, dtype={{PYTYPE}}))
    return st_multi



@cython.boundscheck(False)
@cython.wraparound(False)
def _safe_simplextree_multify_{{FSHORT}}2(simplextree:SimplexTree,int num_parameters=2, cnp.ndarray default_values=np.array(-np.inf))->SimplexTreeMulti_{{FSHORT}}:
    if isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
        return simplextree
    st_multi = SimplexTreeMulti_{{FSHORT}}(num_parameters=num_parameters)
    if default_values.squeeze().ndim == 0:
        default_values = np.zeros(num_parameters-1) + default_values
    cdef int num_simplices = simplextree.num_simplices()
    cdef int max_dim = simplextree.dimension()
    dims = np.fromiter((len(s)-1 for s,_ in simplextree.get_simplices()), dtype=np.int32, count=num_simplices)
    dims = np.unique_counts(dims).counts
    cdef int[:] cdims = np.cumsum(np.concatenate([[0],dims])).astype(np.int32)
    
    # filtration_values = np.asarray([np.concatenate(([f],default_values)) for s,f in simplextree.get_simplices()])
    cdef double [:,:] filtration_values = np.fromiter((np.concatenate((np.asarray(f)[None],default_values)) for s,f in simplextree.get_simplices()), dtype=np.dtype((np.float64,num_parameters)), count=num_simplices)

    cdef int32_t[:,:] batch_simplices = np.fromiter((np.concatenate([s,np.empty(max_dim+2-len(s))]) for s,f in simplextree.get_simplices()), dtype=np.dtype((np.int32,max_dim+2)), count=num_simplices)
    # print(filtration_values.shape, batch_simplices.shape)
    for i in range(max_dim+1):
        S = batch_simplices[cdims[i]:cdims[i+1]][:,:i+1].T
        F = filtration_values[cdims[i]:cdims[i+1]]
        st_multi.insert_batch(S, F)
        # print(f"adding {S.shape,F.shape}")
    return st_multi
{{endfor}}

global available_simplextrees, SimplexTreeMulti_type
available_simplextrees = tuple((
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
    SimplexTreeMulti_{{FSHORT}},
  {{endfor}}
))
SimplexTreeMulti_type:type= Union[
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
    SimplexTreeMulti_{{FSHORT}},
  {{endfor}}
]

def is_simplextree_multi(input)->bool:
  return (False
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
    or isinstance(input, SimplexTreeMulti_{{FSHORT}})
  {{endfor}}
  )





def SimplexTreeMulti(input=None, int num_parameters=-1, dtype:type = np.float64, bool kcritical = False,**kwargs) ->  SimplexTreeMulti_type:
    """SimplexTreeMulti constructor.

    :param other: If `other` is `None` (default value), an empty `SimplexTreeMulti` is created.
        If `other` is a `SimplexTree`, the `SimplexTreeMulti` is constructed from a deep copy of `other`.
        If `other` is a `SimplexTreeMulti`, the `SimplexTreeMulti` is constructed from a deep copy of `other`.
    :type other: SimplexTree or SimplexTreeMulti (Optional)
    :param num_parameters: The number of parameter of the multi-parameter filtration.
    :type num_parameters: int
    :returns: An empty or a copy simplex tree.
    :rtype: SimplexTreeMulti

    :raises TypeError: In case `other` is neither `None`, nor a `SimplexTree`, nor a `SimplexTreeMulti`.
    """
    cdef dict[tuple[type, bool], type] _st_map = {
        {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
        (np.dtype({{PYTYPE}}),{{is_kcritical}}): SimplexTreeMulti_{{FSHORT}},
        {{endfor}}
    }
    # TODO : check that + kcriticality
    # if input is not None:
    #   assert input.dtype is dtype, "SimplexTree conversions are not yet implemented"

    return _st_map[(np.dtype(dtype), kcritical)](input, num_parameters=num_parameters, **kwargs)




## SIGNED MEASURES  STUFF 
from multipers.grids import sms_in_grid

ctypedef int32_t indices_type # uint fails for some reason
python_indices_type=np.int32

ctypedef int32_t tensor_dtype
python_tensor_dtype = np.int32


ctypedef pair[vector[vector[indices_type]], vector[tensor_dtype]] signed_measure_type

cdef extern from "multi_parameter_rank_invariant/hilbert_function.h" namespace "Gudhi::multiparameter::hilbert_function":
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
  signed_measure_type get_hilbert_signed_measure(Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]&, tensor_dtype* , const vector[indices_type], const vector[indices_type], bool, indices_type, bool, bool) except + nogil
  {{endfor}}




## Aligns python/cpp
cdef inline signed_measure_type _hilbert_sm_from_simplextree(object simplextree, tensor_dtype* container_ptr, const vector[indices_type]& c_grid_shape, const vector[indices_type]& degrees, bool zero_pad, indices_type n_jobs, bool verbose, bool expand_collapse):
  cdef intptr_t simplextree_ptr = simplextree.thisptr
  if False:
    pass
{{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
  elif isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
    with nogil:
      return get_hilbert_signed_measure(dereference(<Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]*>simplextree_ptr), container_ptr, c_grid_shape, degrees, zero_pad, n_jobs, verbose, expand_collapse)
{{endfor}}
  else:
    raise ValueError("Input {simplextree} not supported.")

def _hilbert_signed_measure(simplextree, 
    vector[indices_type] degrees, 
    mass_default=None, 
    plot=False, 
    indices_type n_jobs=0, 
    bool verbose=False,
    bool expand_collapse=False, 
    # grid_conversion = None,
    ):
  """
  Computes the signed measures given by the decomposition of the hilbert function.

  Input
  -----

   - simplextree:SimplexTreeMulti, the multifiltered simplicial complex
   - degrees:array-like of ints, the degrees to compute
   - mass_default: Either None, or 'auto' or 'inf', or array-like of floats. Where to put the default mass to get a zero-mass measure.
   - plot:bool, plots the computed measures if true.
   - n_jobs:int, number of jobs. Defaults to #cpu, but when doing parallel computations of signed measures, we recommend setting this to 1.
   - verbose:bool, prints c++ logs.
  
  Output
  ------
  
  `[signed_measure_of_degree for degree in degrees]`
  with `signed_measure_of_degree` of the form `(dirac location, dirac weights)`.
  """

  assert simplextree.is_squeezed, "Squeeze grid first."
  cdef bool zero_pad = mass_default is not None
  # assert simplextree.num_parameters == 2
  grid_shape = np.array([len(f) for f in simplextree.filtration_grid])
  if mass_default is None:
    mass_default = mass_default
  else:
    mass_default = np.asarray(mass_default)
    assert mass_default.ndim == 1 and mass_default.shape[0] == simplextree.num_parameters
  if zero_pad:
    for i, _ in enumerate(grid_shape):
      grid_shape[i] += 1 # adds a 0
    # if grid_conversion is not None:
    #   grid_conversion = tuple(np.concatenate([f, [mass_default[i]]]) for i,f in enumerate(grid_conversion))
  assert len(grid_shape) == simplextree.num_parameters, "Grid shape size has to be the number of parameters."
  grid_shape_with_degree = np.asarray(np.concatenate([[len(degrees)], grid_shape]), dtype=python_indices_type)
  container_array = np.ascontiguousarray(np.zeros(grid_shape_with_degree, dtype=python_tensor_dtype).flatten())
  assert len(container_array) < np.iinfo(np.uint32).max, "Too large container. Raise an issue on github if you encounter this issue. (Due to tensor's operator[])"
  cdef intptr_t simplextree_ptr = simplextree.thisptr
  cdef vector[indices_type] c_grid_shape = grid_shape_with_degree
  cdef tensor_dtype[::1] container = container_array
  cdef tensor_dtype* container_ptr = &container[0]
  cdef signed_measure_type out = _hilbert_sm_from_simplextree(simplextree, container_ptr, c_grid_shape, degrees, zero_pad, n_jobs, verbose, expand_collapse)
  pts, weights = np.asarray(out.first, dtype=python_indices_type).reshape(-1, simplextree.num_parameters+1), np.asarray(out.second, dtype=python_tensor_dtype)
  slices = np.concatenate([np.searchsorted(pts[:,0], np.arange(degrees.size())), [pts.shape[0]] ])
  sms = [
      (pts[slices[i]:slices[i+1],1:],weights[slices[i]:slices[i+1]])
      for i in range(slices.shape[0]-1)
  ]
  # if grid_conversion is not None:
  #   sms = sms_in_grid(sms,grid_conversion)

  # if plot:
  #   from multipers.plots import plot_signed_measures
  #   plot_signed_measures(sms)
  return sms


#### EULER CHAR

cdef extern from "multi_parameter_rank_invariant/euler_characteristic.h" namespace "Gudhi::multiparameter::euler_characteristic":
  # void get_euler_surface_python(const intptr_t, tensor_dtype*, const vector[indices_type], bool, bool, bool) except + nogil
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
  signed_measure_type get_euler_signed_measure(Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]&, tensor_dtype* , const vector[indices_type], bool, bool) except + nogil
  {{endfor}}


## Aligns python/cpp
cdef inline signed_measure_type _euler_sm_from_simplextree(object simplextree, tensor_dtype* container_ptr, const vector[indices_type]& c_grid_shape,  bool zero_pad, bool verbose):
  cdef intptr_t simplextree_ptr = simplextree.thisptr
  if False:
    pass
{{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
{{if not is_kcritical}}
  elif isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
    with nogil:
      return get_euler_signed_measure(dereference(<Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]*>simplextree_ptr), container_ptr, c_grid_shape, zero_pad, verbose)
{{endif}}
{{endfor}}
  else:
    raise ValueError("Input {simplextree} not supported.")


def _euler_signed_measure(simplextree, mass_default=None, bool verbose=False):
  """
  Computes the signed measures given by the decomposition of the hilbert function.

  Input
  -----

   - simplextree:SimplexTreeMulti, the multifiltered simplicial complex
   - mass_default: Either None, or 'auto' or 'inf', or array-like of floats. Where to put the default mass to get a zero-mass measure.
   - plot:bool, plots the computed measures if true.
   - n_jobs:int, number of jobs. Defaults to #cpu, but when doing parallel computations of signed measures, we recommend setting this to 1.
   - verbose:bool, prints c++ logs.
  
  Output
  ------

  `[signed_measure_of_degree for degree in degrees]`
  with `signed_measure_of_degree` of the form `(dirac location, dirac weights)`.
  """
  if not simplextree.is_squeezed:
      raise ValueError("Squeeze grid first.")
  cdef bool zero_pad = mass_default is not None
  # assert simplextree.num_parameters == 2
  grid_shape = np.array([len(f) for f in simplextree.filtration_grid])
  
  if mass_default is None:
    mass_default = mass_default
  else:
    mass_default = np.asarray(mass_default)
    assert mass_default.ndim == 1 and mass_default.shape[0] == simplextree.num_parameters
  if zero_pad:
    for i, _ in enumerate(grid_shape):
      grid_shape[i] += 1 # adds a 0
    # if grid_conversion is not None:
    #   grid_conversion = tuple(np.concatenate([f, [mass_default[i]]]) for i,f in enumerate(grid_conversion))
  assert len(grid_shape) == simplextree.num_parameters, "Grid shape size has to be the number of parameters."
  container_array = np.ascontiguousarray(np.zeros(grid_shape, dtype=python_tensor_dtype).flatten())
  assert len(container_array) < np.iinfo(python_indices_type).max, "Too large container. Raise an issue on github if you encounter this issue. (Due to tensor's operator[])"
  cdef intptr_t simplextree_ptr = simplextree.thisptr
  cdef vector[indices_type] c_grid_shape = grid_shape
  cdef tensor_dtype[::1] container = container_array
  cdef tensor_dtype* container_ptr = &container[0]
  cdef signed_measure_type out

  out = _euler_sm_from_simplextree(simplextree, container_ptr, c_grid_shape, zero_pad, verbose)

  pts, weights = np.asarray(out.first, dtype=python_indices_type).reshape(-1, simplextree.num_parameters), np.asarray(out.second, dtype=python_tensor_dtype)
  # return pts, weights
  sm = (pts,weights)

  return sm









## Rank invariant

cdef extern from "multi_parameter_rank_invariant/rank_invariant.h" namespace "Gudhi::multiparameter::rank_invariant":
  {{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
  void compute_rank_invariant_python(Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]&, tensor_dtype* , const vector[indices_type], const vector[indices_type], indices_type, bool) except + nogil
  {{endfor}}


## Aligns python/cpp
cdef inline void _rank_sm_from_simplextree(object simplextree, tensor_dtype* container_ptr, const vector[indices_type]& c_grid_shape, const vector[indices_type]& degrees, indices_type n_jobs, bool expand_collapse):
  cdef intptr_t simplextree_ptr = simplextree.thisptr
  if False:
    pass
{{for CTYPE,PYTYPE,SHORT,Filtration, is_kcritical, FSHORT in to_iter}}
  elif isinstance(simplextree, SimplexTreeMulti_{{FSHORT}}):
    with nogil:
      compute_rank_invariant_python(dereference(<Simplex_tree_multi_interface[{{FSHORT}}, {{CTYPE}}]*>simplextree_ptr), container_ptr, c_grid_shape, degrees, n_jobs, expand_collapse)
{{endfor}}
  else:
    raise ValueError("Input {simplextree} not supported.")


def _rank_signed_measure(simplextree, vector[indices_type] degrees, mass_default=None, plot=False, indices_type n_jobs=0, bool verbose=False, bool expand_collapse=False):
    """
    Computes the signed measures given by the decomposition of the hilbert function.

    Input
    -----

     - simplextree:SimplexTreeMulti, the multifiltered simplicial complex
     - degrees:array-like of ints, the degrees to compute
     - mass_default: Either None, or 'auto' or 'inf', or array-like of floats. Where to put the default mass to get a zero-mass measure.
     - plot:bool, plots the computed measures if true.
     - n_jobs:int, number of jobs. Defaults to #cpu, but when doing parallel computations of signed measures, we recommend setting this to 1.
     - verbose:bool, prints c++ logs.

    Output
    ------

    `[signed_measure_of_degree for degree in degrees]`
    with `signed_measure_of_degree` of the form `(dirac location, dirac weights)`.
    """
    assert simplextree.is_squeezed, "Squeeze grid first."
    cdef bool zero_pad = mass_default is not None
    # grid_conversion = [np.asarray(f) for f in simplextree.filtration_grid]
    # assert simplextree.num_parameters == 2
    # grid_shape = np.array([len(f) for f in grid_conversion])
    grid_shape = np.array([len(f) for f in simplextree.filtration_grid])

    if mass_default is None:
        mass_default = mass_default
    else:
        mass_default = np.asarray(mass_default)
        assert mass_default.ndim == 1 and mass_default.shape[0] == simplextree.num_parameters, "Mass default has to be an array like of shape (num_parameters,)"
    # if zero_pad:
    #     for i, _ in enumerate(grid_shape):
    #         grid_shape[i] += 1 # adds a 0
        # grid_conversion = tuple(np.concatenate([f, [mass_default[i]]]) for i,f in enumerate(grid_conversion))

    assert len(grid_shape) == simplextree.num_parameters, "Grid shape size has to be the number of parameters."
    grid_shape_with_degree = np.asarray(np.concatenate([[len(degrees)], grid_shape, grid_shape]), dtype=python_indices_type)
    container_array = np.ascontiguousarray(np.zeros(grid_shape_with_degree, dtype=python_tensor_dtype).flatten())
    assert len(container_array) < np.iinfo(python_indices_type).max, "Too large container. Raise an issue on github if you encounter this issue. (Due to tensor's operator[])"
    cdef intptr_t simplextree_ptr = simplextree.thisptr
    cdef vector[indices_type] c_grid_shape = grid_shape_with_degree
    cdef tensor_dtype[::1] container = container_array
    cdef tensor_dtype* container_ptr = &container[0]
    _rank_sm_from_simplextree(simplextree, container_ptr,c_grid_shape,degrees, n_jobs, expand_collapse)
    rank = container_array.reshape(grid_shape_with_degree)
    rank = tuple(rank_decomposition_by_rectangles(rank_of_degree, threshold = zero_pad) for rank_of_degree in rank)
    out = []
    cdef int num_parameters = simplextree.num_parameters
    for rank_decomposition in rank:
        (coords, weights) = sparsify(np.ascontiguousarray(rank_decomposition))
        births = coords[:,:num_parameters]
        deaths = coords[:,num_parameters:]
        correct_indices = np.all(births<=deaths, axis=1) # TODO : correct this
        coords = coords[correct_indices]
        weights = weights[correct_indices]
        if len(correct_indices) == 0:
            coords, weights = np.empty((0, 2*num_parameters)), np.empty((0))
        # else:
        #     pts = np.empty(shape=coords.shape, dtype=grid_conversion[0].dtype)
        #     for i in range(pts.shape[1]):
        #         pts[:,i] = grid_conversion[i % num_parameters][coords[:,i]]
        rank_decomposition = (coords,weights)
        out.append(rank_decomposition)

    #  if plot:
    #      from multipers.plots import plot_signed_measures
    #      plot_signed_measures(out)
    return out

