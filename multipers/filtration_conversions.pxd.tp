{{py:

"""
Filtrations conversions between python and C++
"""

## Value types : CTYPE, PYTHON_TYPE, short
value_types = [
  ("int32_t", "np.int32", "i32"),
  ("int64_t", "np.int64", "i64"),
  ("float", "np.float32", "f32"),
  ("double", "np.float64", "f64"),
]

}}

# Python to C++ conversions
from multipers.filtrations cimport One_critical_filtration,Multi_critical_filtration
from libcpp.vector cimport vector
from libcpp cimport bool
cimport numpy as cnp
import numpy as np
from libc.stdint cimport int32_t, int64_t
from cython.operator cimport dereference

{{for CTYPE, PYTYPE, SHORT in value_types}}
###### ------------------- PY TO CPP
#### ---------- 

cdef inline vector[{{CTYPE}}] _py2p_{{SHORT}}({{CTYPE}}[:] filtration) noexcept nogil:
    # TODO: Is there no directer way to convert a T[:] into a vector[T]?
    # A memcpy would be much quicker than a python for loop...
    # With a continuous memory use, we could also pass the pointers as iterators if we have access to it?
    cdef vector[{{CTYPE}}] f = vector[{{CTYPE}}](len(filtration))
    for i in range(len(filtration)):
      f[i] = filtration[i]
    return f

cdef inline Multi_critical_filtration[{{CTYPE}}] _py2kc_{{SHORT}}({{CTYPE}}[:,:] filtrations) noexcept nogil:
    # cdef {{CTYPE}}[:,:] filtrations = np.asarray(filtrations_, dtype={{PYTYPE}})
    cdef vector[{{CTYPE}}] f = vector[{{CTYPE}}](filtrations.shape[0] * filtrations.shape[1])
    cdef int k = 0;
    for i in range(filtrations.shape[0]):
        for j in range(filtrations.shape[1]):
            f[k] = filtrations[i,j]
            k = k + 1
    cdef Multi_critical_filtration[{{CTYPE}}] out = Multi_critical_filtration[{{CTYPE}}](f.begin(), f.end(), filtrations.shape[1])
    out.simplify()
    return out

cdef inline One_critical_filtration[{{CTYPE}}] _py21c_{{SHORT}}({{CTYPE}}[:] filtration) noexcept nogil:
    cdef One_critical_filtration[{{CTYPE}}] out = _py2p_{{SHORT}}(filtration)
    return out


cdef inline vector[One_critical_filtration[{{CTYPE}}]] _py2v1c_{{SHORT}}({{CTYPE}}[:,:] filtrations) noexcept nogil:
    # cdef {{CTYPE}}[:,:] filtrations = np.asarray(filtrations_, dtype={{PYTYPE}})
    cdef vector[One_critical_filtration[{{CTYPE}}]] out
    cdef vector[{{CTYPE}}] f = vector[{{CTYPE}}](filtrations.shape[1])
    out.reserve(filtrations.shape[0])
    for i in range(filtrations.shape[0]):
        for j in range(filtrations.shape[1]):
          f[j] = filtrations[i,j]
        out.emplace_back(f)
    return out

###### ------------------- CPP to PY


## CYTHON BUG: using tuples here will cause some weird issues. 
cdef inline _ff21cview_{{SHORT}}(One_critical_filtration[{{CTYPE}}]* x, bool copy=False, int duplicate=0):
  cdef Py_ssize_t num_parameters = dereference(x).num_parameters()
  if copy and duplicate and not dereference(x).is_finite():
    return np.full(shape=duplicate, fill_value=dereference(x)(0,0))
  cdef {{CTYPE}}[:] x_view = <{{CTYPE}}[:num_parameters]>(&(dereference(x)(0,0)))
  return np.array(x_view) if copy else np.asarray(x_view)

cdef inline _ff21cview2_{{SHORT}}({{CTYPE}}* x, Py_ssize_t num_parameters, bool copy=False, int duplicate=0):
  if copy and duplicate and not dereference(x).is_finite():
    return np.full(shape=duplicate, fill_value=dereference(x))
  cdef {{CTYPE}}[:] x_view = <{{CTYPE}}[:num_parameters]>(x)
  return np.array(x_view) if copy else np.asarray(x_view)

cdef inline _ff2kcview_{{SHORT}}(Multi_critical_filtration[{{CTYPE}}]* x, bool copy=False, int duplicate=0):
  cdef Py_ssize_t k = dereference(x).num_generators()
  return [_ff21cview2_{{SHORT}}(&(dereference(x)(i,0)), dereference(x).num_parameters(), copy=copy, duplicate=duplicate) for i in range(k)]


cdef inline  _vff21cview_{{SHORT}}(vector[One_critical_filtration[{{CTYPE}}]]& x, bool copy = False, int duplicate=0):
  cdef Py_ssize_t num_stuff = x.size()
  return [_ff21cview_{{SHORT}}(&(x[i]), copy=copy, duplicate=duplicate) for i in range(num_stuff)]

cdef inline  _vff2kcview_{{SHORT}}(vector[Multi_critical_filtration[{{CTYPE}}]]& x, bool copy = False, int duplicate=0):
  cdef Py_ssize_t num_stuff = x.size()
  return [_ff2kcview_{{SHORT}}(&(x[i]), copy=copy, duplicate=duplicate) for i in range(num_stuff)]

{{endfor}}

